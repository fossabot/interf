{"version":3,"sources":["interf.js"],"names":["root","factory","define","amd","module","exports","interf","nodeName","Number","isInteger","VERSION","this","assignObjects","len","arguments","length","i","ret","mergeObjects","parentHas","target","Interface","prototype","getProto","interfaces","constructor","__interfaces_","has","create","interfaceName","extendsArray","ar","obj","name","extends","InterfaceClass","TypeError","defineInterfacesProp","proto","parent","options","value","Interfaces","version","descriptor","_config","set","Object","defineProperty","debug","debugs","validateInterfaces","isInterfaceOf","implementIn","hasProp","call","add","afterImplement","callbacks","implement","removeIn","missed","deleted","collection","success","interfaced","index","indexOf","warnMsg","remove","push","warn","message","addArray","map","join","emptyIn","empty","resolveArgs","args","section","values","Array","isArray","targetProto","in","getOwnPropsKeys","getOwnPropertyNames","getSymbols","implementByMixIn","interfs","splice","defineProps","mixin","ignore","mixinNames","targetNames","debugData","operation","ignoredNames","notReplaced","replaced","defined","writed","getOwnPropertyDescriptor","__mixins_","mixins","isProto","replace","targetDescriptor","configurable","writable","notConfigurableNotWritableError","console","error","e","mixProperties","createInitMixins","j","mixinObject","Function","bind","apply","keys","mixIn","targetPrototype","mixinsConstructors","mixinProto","protoProps","staticProps","createInit","MixinsInitiable","debugIn","actions","information","debugInfo","DebugInterfaces","duplicates","getDuplicates","tree","getTree","list","getList","getPrototypeOf","__proto__","source","destination","getOwnPropertySymbols","hasOwnProperty","enumerable","data","log","classInterfaces","Class","CAPITAL_CHARS","split","properties","Error","object","constructorName","extendsHas","opts","configure","utils","internal","Comments","Methods","StaticProperties","Docs","initTree","initList","unshift","addInfo","extended","InterFace","info","asExtendedInterface","result","interface","implementedIn","results","Constructor","allInterfaces","stillExist","interfacesList","listLen","listednterface","isPrototype","mix","action","allActions"],"mappings":";;;;;;AAMC,EAAEA,EAAMC,KACP,GAAsB,mBAAXC,QAAyBA,OAAOC,IAEzCD,UAAWD,QACN,GAAsB,iBAAXG,QAAuBA,OAAOC,QAAS,CAEvD,MAAMC,EAASL,IACfG,OAAOC,QAAUC,EAEjBF,OAAOC,QAAQC,OAASA,MACI,iBAAZD,SAAoD,iBAArBA,QAAQE,SAEvDF,QAAQC,OAASL,IACe,iBAAhBD,EAAKM,QAAwBE,OAAOC,UAAUT,EAAKM,OAAOI,WAC1EV,EAAKM,OAASL,OAEfU,KAAM,KA8CP,SAASC,IACP,MAAMC,EAAMC,UAAUC,OACtB,IAAIC,GAAK,EACLC,KACJ,OAASD,EAAIH,GACXI,EAAMC,EAAaD,EAAKH,UAAUE,IAEpC,OAAOC,EA4ET,SAASE,EAAUC,EAAQC,GACzB,MAAMC,EAAYC,EAASH,GAC3B,GAAkB,OAAdE,EAAoB,OAAO,EAC/B,MAAME,EAAaF,EAAUG,YAAYC,cACzC,aAA0B,IAAfF,IAA8BA,EAAWG,IAAIN,KACjDF,EAAUG,EAAWD,GA0C9B,SAASO,EAAOC,EAAeC,GAG7B,MAAMC,EAAKjB,UACX,GAAqB,iBAAViB,EAAG,GAAiB,CAC7B,MAAMC,GAAQC,KAAMF,EAAG,IAEvB,YADqB,IAAVA,EAAG,KAAoBC,EAAIE,QAAUH,EAAG,IAC5C,IAAII,EAAeH,GACrB,GAAqB,iBAAVD,EAAG,GACnB,OAAO,IAAII,EAAeJ,EAAG,IAE/B,MAAMK,UACJ,iFAiGJ,SAASC,EAAqBC,EAAOC,EAAQC,GAC3C,MAAMC,EAAQ,IAAIC,EAAWpC,EAAOqC,QAASJ,GACvCK,EAAahC,EAAc4B,EAAQI,YAEI,mBAAlCtC,EAAOuC,QAAQD,WAAWE,MACnCF,EAAWH,MAAQA,GAGrBM,OAAOC,eAAeV,EAAMb,YAAa,gBAAiBmB,GAC5B,mBAAnBA,EAAWE,MACpBR,EAAMb,YAAYC,cAAgBe,GAGhCD,EAAQS,OAASC,GAAQA,EAAOhD,QAAO,EAAMoC,EAAOG,GAG1D,SAASU,EAAmB3B,GAC1B,IAAIR,EAAIQ,EAAWT,OACnB,KAAOC,KAAK,CACV,GAA6B,iBAAlBQ,EAAWR,GACpB,MAAMoB,mCAAmCZ,EAAWR,mBAC/C,GAA2C,mBAAhCQ,EAAWR,GAAGoC,cAC9B,MAAMhB,0CAA0CZ,EAAWR,GAAGiB,SAMpE,SAASoB,EAAY/B,EAAWE,EAAYgB,GAC1CW,EAAmB3B,GAEnB,MAAMC,EAAcH,EAAUG,YAe9B,OAbK6B,EAAQC,KAAK9B,EAAa,kBAC7BY,EAAqBf,EAAW,KAAMkB,GAIxCf,EAAYC,cAAc8B,IAAIhC,EAAYC,EAAYQ,MAElD3B,EAAOuC,QAAQY,gBACjBnD,EAAOuC,QAAQa,UAAUD,eAAehC,EAAYC,cAAeD,EAAaD,GAG9EgB,EAAQS,OAASC,GAAQA,EAAOS,WAAU,EAAMrC,EAAWE,GAExDC,EAIT,SAASmC,EAAStC,EAAWE,EAAYgB,GACvCW,EAAmB3B,GAEnB,MAAMC,EAAcH,EAAUG,YACxBoC,KACAC,KACN,IAAIC,EACAC,GAAU,EACVC,GAAa,EACjB,GAAIX,EAAQC,KAAK9B,EAAa,iBAAkB,CAC9CsC,EAAatC,EAAYC,cAAcqC,WAEvC,IAAI/C,EAAIQ,EAAWT,OAEnB,KAAOC,KAAK,CACV,MAAMkD,EAAQH,EAAWI,QAAQ3C,EAAWR,IAC5C,IAAIoD,EAAU,GAEVF,GAAS,EACPzC,EAAYC,cAAc2C,OAAO7C,EAAWR,KAC9C8C,EAAQQ,KAAK9C,EAAWR,IAEpBS,EAAYC,cAAcC,IAAIH,EAAWR,MAC3CoD,qEAGEjD,EAAUG,EAAWE,EAAWR,MAClCoD,0FAGFA,sCAGFA,iCAEAP,EAAOS,KAAK9C,EAAWR,KAGrBwB,EAAQ+B,MAAQH,EAAQrD,OAAS,GACnCT,EAAOuC,QAAQa,UAAUa,MACvBC,uBAAwB/C,EAAYQ,mBAAmBT,EAAWR,GAC/DiB,YAAYmC,MAKrBJ,EAAUF,EAAQ/C,SAAWS,EAAWT,OAExCkD,GAAa,OACJzB,EAAQ+B,MACjBjE,EAAOuC,QAAQa,UAAUa,MACvBC,uBAAwB/C,EAAYQ,6CAA6CwC,KAE/EjD,GAECkD,IAAIrD,GAAaA,EAAUY,MAC3B0C,KAAK,+CAQZ,OAJInC,EAAQS,OAASC,GACnBA,EAAOmB,OAAOL,EAAS1C,EAAWE,EAAYyC,EAAYH,EAASD,GAG9DG,EAIT,SAASY,EAAQtD,EAAWkB,GAC1B,MAAMf,EAAcH,EAAUG,YAC9B,IAAIuC,GAAU,EACVC,GAAa,EACjB,GAAIX,EAAQC,KAAK9B,EAAa,iBAAkB,CAE9C,MAAMD,EAAaiD,KAAahD,EAAYC,cAAcqC,YAChC,IAAtBvC,EAAWT,SACbiD,EAAUJ,EAAStC,EAAWE,EAAYgB,IAG5CyB,GAAa,EAKf,OAFIzB,EAAQS,OAASC,GAAQA,EAAO2B,MAAMb,EAAS1C,EAAW,KAAM2C,GAE7DD,EAIT,SAASc,EAAYC,EAAMC,GACzB,MAAM/D,GAAQgE,OAAQF,EAAMvC,YAC5B,IAAII,EAuBJ,OAtBIsC,MAAMC,QAAQJ,EAAK,MACrB9D,EAAIgE,OAASF,EAAK,GACK,iBAAZA,EAAK,KACd9D,EAAIuB,QAAUuC,EAAK,GACmB,iBAA3B9D,EAAIuB,QAAQI,aACrBA,EAAa3B,EAAIuB,QAAQI,cAM7B3B,EAAIuB,QADiB,iBAAZwC,EACKpE,EAAcN,EAAOuC,QAASvC,EAAOuC,QAAQmC,GAAU/D,EAAIuB,SAE3D5B,EAAcN,EAAOuC,QAAS5B,EAAIuB,cAKxB,IAAfI,IACT3B,EAAIuB,QAAQI,WAAaA,GAGpB3B,EAIT,SAASmE,EAAYhE,GACnB,GAAsB,mBAAXA,EACT,OAAOA,EAAOE,UACT,GAEyB,mBAAvBF,EAAOK,aACdL,EAAOK,YAAYH,YAAcF,EAEjC,OAAOA,EAET,MAAMgB,uGACyFhB,MAKjG,SAASuC,IAEP,MAAMoB,EAAOD,EAAYhE,WACzB,OACEuE,GAAIjE,GAAUiC,EAAY+B,EAAYhE,GAAS2D,EAAKE,OAAQF,EAAKvC,UA+QrE,SAAS8C,EAAgBlE,GACvB,OAAOqD,EAAS1B,OAAOwC,oBAAoBnE,GAASoE,EAAWpE,IAGjE,SAASqE,EAAiBrE,EAAQI,EAAYgB,GAC5C,MAAMlB,EAAY8D,EAAYhE,GAExBsE,EAAUjB,KAAajD,GAE7B,IAAIR,EAAI0E,EAAQ3E,OAEhB,KAAOC,KAGHsC,EAAQC,KAAKjC,EAAUG,YAAa,kBACpCH,EAAUG,YAAYC,cAAcqC,WAAWI,QAAQuB,EAAQ1E,KAAO,GAEtE0E,EAAQC,OAAO3E,EAAG,GAItB,OAAOqC,EAAY/B,EAAWoE,EAASlD,GAIzC,SAASoD,EAAYxE,EAAQyE,EAAOrD,EAASsD,GAC3C,MAAMC,EAAaT,EAAgBO,GAC7BG,EAAcV,EAAgBlE,GAC9B6E,GACJC,UAAW,gBACX9E,OAAAA,EACAyE,MAAAA,EACAM,gBACAC,eACAC,YACAC,WACAC,WAGF,IAAIvF,EAAI+E,EAAWhF,OAEnB,KAAOC,KAAK,CAEV,GAAI8E,EAAO3B,QAAQ4B,EAAW/E,KAAO,EAAG,CAClCwB,EAAQS,OAAOgD,EAAUE,aAAa7B,KAAKyB,EAAW/E,IAC1D,SAGF,GAAsB,kBAAlB+E,EAAW/E,GAAwB,CACjCwB,EAAQhB,aACViE,EAAiBrE,EAAQyE,EAAMnE,cAAcqC,WAAYvB,GACrDA,EAAQS,QAAOgD,EAAUzE,WAAaqE,EAAMnE,cAAcqC,aAEhE,SAGF,MAAMnB,EAAaG,OAAOyD,yBAAyBX,EAAOE,EAAW/E,IAErE,GAAIgF,EAAY7B,QAAQ4B,EAAW/E,KAAO,EAExC,GAAsB,cAAlB+E,EAAW/E,GACbyD,EAASrD,EAAOqF,UAAWZ,EAAMY,WAC7BjE,EAAQS,QAAOgD,EAAUS,OAASb,EAAMY,eACvC,CACL,MAAME,EAA4B,iBAAXvF,EAcvB,GAZIoB,EAAQ+B,MACVjE,EAAOuC,QAAQa,UAAUa,MACvBC,kBAAmBmC,KACZvF,EAAOK,YAAYQ,iBACtBb,EAAOa,2BAA2B0E,KAC/Bd,EAAMpE,YAAYQ,iBACrB4D,EAAM5D,mBAAmB8D,EAAW/E,gBAAgBwB,EAAQoE,QAC5D,WACA,eAIJpE,EAAQoE,QAAS,CAEnB,MAAMC,EAAmB9D,OAAOyD,yBAAyBpF,EAAQ2E,EAAW/E,IAC5E,GAAK6F,EAAiBC,aA8BpB/D,OAAOC,eAAe5B,EAAQ2E,EAAW/E,GAAI4B,GACzCJ,EAAQS,OAAOgD,EAAUI,SAAS/B,KAAKyB,EAAW/E,SA9BtD,GAAI6F,EAAiBE,SAEnB3F,EAAO2E,EAAW/E,IAAM6E,EAAME,EAAW/E,IACrCwB,EAAQS,OAAOgD,EAAUM,OAAOjC,KAAKyB,EAAW/E,SAC/C,GAAIwB,EAAQwE,gCAAiC,CAClD,IAEEC,QAAQC,MACN,oFACAjB,GAEF,MAAOkB,IAETpE,OAAOC,eAAe5B,EAAQ2E,EAAW/E,GAAI4B,QAGzCJ,EAAQS,OAAOgD,EAAUG,YAAY9B,KAAKyB,EAAW/E,IACrDwB,EAAQ+B,MACVjE,EAAOuC,QAAQa,UAAUa,MACvBC,iBAAkBmC,KACXd,EAAMpE,YAAYQ,iBACrB4D,EAAM5D,kBAAkB8D,EAC1B/E,mEAUDwB,EAAQS,OAEjBgD,EAAUG,YAAY9B,KAAKyB,EAAW/E,SAK1C+B,OAAOC,eAAe5B,EAAQ2E,EAAW/E,GAAI4B,GACzCJ,EAAQS,OAAOgD,EAAUK,QAAQhC,KAAKyB,EAAW/E,IAIrDwB,EAAQS,OAASC,GAAQA,EAAOkE,eAAc,EAAMhG,EAAQyE,EAAOI,GAKzE,SAASoB,EAAiBT,GACxB,OAAO,WAEL,IAAItF,EAAYC,EAASZ,MACzB,OAAa,CACX,GAAkB,OAAdW,EACF,MAGF,GAAIgC,EAAQC,KAAKjC,EAAUG,YAAa,aAAc,CACpD,MAAMV,EAASO,EAAUG,YAAYgF,UAAU1F,OAC/C,IAAIuG,GAAK,EACT,OAASA,EAAIvG,GAAQ,CAGnB,MAAMwG,EAAc,IAAKC,SAASlG,UAAUmG,KAAKC,MAC/CpG,EAAUG,YAAYgF,UAAUa,GAChC7C,GAAU,MAAO3D,aAEb6G,EAAO5E,OAAO4E,KAAKJ,GACzB,IAAIvG,EAAI2G,EAAK5G,OAEb,KAAOC,WACwB,IAAlBL,KAAKgH,EAAK3G,KAAuB4F,KAC1CjG,KAAKgH,EAAK3G,IAAMuG,EAAYI,EAAK3G,MAMzCM,EAAYC,EAASD,KAM3B,SAASsG,EAAMC,EAAiBnB,EAAQlE,GACtC,MAAMsF,KACAjH,EAAM6F,EAAO3F,OACnB,IAAIC,GAAK,EACT,OAASA,EAAIH,GAAK,CAChB,MAAMkH,EAAa3C,EAAYsB,EAAO1F,IACtC4E,EAAYiC,EAAiBE,EAAYvF,EAASA,EAAQsD,OAAOkC,YACjEpC,EACEiC,EAAgBpG,YAChBsG,EAAWtG,YACXe,EACAA,EAAQsD,OAAOmC,aAEbzF,EAAQ0F,YAAYJ,EAAmBxD,KAAKyD,EAAWtG,aAiC7D,OA9BIe,EAAQ0F,kBAEiC,IAAlCL,EAAgBnG,eACtBmG,EAAgBnG,cAAcC,IAAIwG,KAEnCpF,OAAOC,eAAe6E,EAAiB,cACrCf,cAAc,EACdC,UAAU,EACVtE,MAAO4E,IAAmB7E,EAAQoE,WAImB,iBAA9CiB,EAAgBpG,YAAYC,gBACgD,IAAnFmG,EAAgBpG,YAAYC,cAAcqC,WAAWI,QAAQgE,IAE7DxE,EAAUwE,GAAiB9C,GAAGwC,IAI9BvE,EAAQC,KAAKsE,EAAgBpG,YAAa,aAC5CgD,EAASoD,EAAgBpG,YAAYgF,UAAWqB,GAEhD/E,OAAOC,eAAe6E,EAAgBpG,YAAa,aACjDqF,cAAc,EACdC,UAAU,EACVtE,MAAOqF,KAKND,EAAgBpG,YAIzB,SAAS2G,EAAQ9G,EAAW+G,GAC1B,MAAMC,KACN,IAAItH,EAAIqH,EAAQtH,OAChB,MAAMwH,EAAY,IAAIC,EAAgBlH,GAGtC,KAAON,KACc,eAAfqH,EAAQrH,GACVsH,EAAYG,WAAaF,EAAUG,gBACX,SAAfL,EAAQrH,GACjBsH,EAAYK,KAAOJ,EAAUK,UACL,SAAfP,EAAQrH,KACjBsH,EAAYO,KAAON,EAAUO,WAIjC,OAAOR,EA18BT,MAAM/G,EAAWwB,OAAOgG,gBAAP,CAA0B/G,GAAOA,EAAIgH,WAEhDvE,EAAW,CAACrD,EAAQ6H,KACxB,MAAMpI,EAAMoI,EAAOlI,OACnB,IAAIC,GAAK,EACT,OAASA,EAAIH,GACXO,EAAOkD,KAAK2E,EAAOjI,IAErB,OAAOI,GAGHF,EAAe,CAACE,EAAQ6H,KAC5B,MAAMC,EAAc9H,EACduG,EAAO5E,OAAO4E,KAAKsB,GACzB,IAAIjI,EAAI2G,EAAK5G,OACb,KAAOC,KACDkE,MAAMC,QAAQ8D,EAAOtB,EAAK3G,KACxBkE,MAAMC,QAAQ+D,EAAYvB,EAAK3G,KAEjCkI,EAAYvB,EAAK3G,IAAMyD,EAASyE,EAAYvB,EAAK3G,IAAKiI,EAAOtB,EAAK3G,KAGlEkI,EAAYvB,EAAK3G,IAAMyD,KAAawE,EAAOtB,EAAK3G,KAEd,iBAApBiI,EAAOtB,EAAK3G,IACQ,iBAAzBkI,EAAYvB,EAAK3G,IAE1BkI,EAAYvB,EAAK3G,IAAME,EAAagI,EAAYvB,EAAK3G,IAAKiI,EAAOtB,EAAK3G,KAGtEkI,EAAYvB,EAAK3G,IAAME,KAAiB+H,EAAOtB,EAAK3G,KAGtDkI,EAAYvB,EAAK3G,IAAMiI,EAAOtB,EAAK3G,IAIvC,OAAOkI,GAcH1D,EAAazC,OAAOoG,uBAAP,SAMb7F,EAAUP,OAAOzB,UAAU8H,eAG3B9I,GAEJI,QAAS,EACTmC,SAEE0B,MAAM,EACNtB,OAAO,EACPQ,gBAAgB,EAChBb,YAEEkE,cAAc,EACdC,UAAU,EACVsC,YAAY,GAId3F,WACEa,KAAM,SAAsB+E,GACH,iBAAZrC,SAAwBA,QAAQ1C,MAAM0C,QAAQ1C,KAAK+E,EAAK9E,UAGrEvB,MAAO,SAAuBqG,GACL,iBAAZrC,SAAwBA,QAAQsC,KAAKtC,QAAQsC,IAAID,EAAK9E,QAAS8E,IAE5E7F,eAAgB,SAAgC+F,EAAiBC,EAAOjI,MAG1EqE,OAGEqC,YAAY,EACZ1G,YAAY,EACZoF,SAAS,EACTI,iCAAiC,EAEjClB,QACEkC,YACE,cACA,QACA,OACA,OACA,cACA,WACA,WACA,aAEFC,aACE,YACA,QACA,SACA,SACA,OACA,cACA,YACA,iBAOJyB,EAAgB,6BAA6BC,MAAM,IAWnDxH,QACJV,YAAYmI,GACV,QAAkC,IAAvBA,EAAW1H,UAA4BgD,MAAMC,QAAQyE,EAAW1H,SACzE,MAAME,UAAU,wCAElB,GAA+B,iBAApBwH,EAAW3H,MAAgD,IAA3B2H,EAAW3H,KAAKlB,OAgBzD,MAAMqB,UAAU,gCAhBuD,CACvE,MAAMuF,EAAO5E,OAAO4E,KAAKiC,GACzB,IAAI5I,EAAI2G,EAAK5G,OAEb,KAAOC,KAAK,CACV,KACE0I,EAAcvF,QAAQwD,EAAK3G,GAAG,KAAO,GACzB,SAAZ2G,EAAK3G,IACO,YAAZ2G,EAAK3G,IAIL,MAAM6I,MAAM,qEAFZlJ,KAAKgH,EAAK3G,IAAM4I,EAAWjC,EAAK3G,MAUxCoC,cAAc0G,GAIZ,MAAMxI,EAAYC,EAASuI,GAC3B,GAAkB,OAAdxI,EAAoB,OAAO,EAC/B,MAAME,EAAaF,EAAUG,YAAYC,cACzC,aAA0B,IAAfF,IAA8BA,EAAWG,IAAIhB,QACjDQ,EAAUG,EAAWX,cAsB1B+B,EACJjB,YAAYkB,GACVhC,KAAKoD,cACLpD,KAAKD,QAAUiC,EAKjBa,IAAIhC,EAAYuI,GACd,MAAMlJ,EAAMW,EAAWT,OACvB,IAAIC,GAAK,EACT,OAASA,EAAIH,GAAK,CAChB,IAAIyG,EAAI3G,KAAKoD,WAAWhD,OAExB,KAAOuG,KACL,GAAI3G,KAAKoD,WAAWuD,KAAO9F,EAAWR,GACpC,MAAM6I,eACKE,uDAAqEvI,EAC5ER,GACAiB,QAKRtB,KAAKoD,WAAWO,KAAK9C,EAAWR,IAElC,OAAOL,KAGT0D,OAAOhD,GACL,IAAIL,EAAIL,KAAKoD,WAAWhD,OAExB,KAAOC,KACL,GAAIK,IAAcV,KAAKoD,WAAW/C,GAEhC,OADAL,KAAKoD,WAAW4B,OAAO3E,EAAG,IACnB,EAGX,OAAO,EAKTW,IAAIN,GACF,IAAIL,EAAIL,KAAKoD,WAAWhD,OAExB,KAAOC,KAAK,CACV,GAAIK,IAAcV,KAAKoD,WAAW/C,GAAI,OAAO,EAE7C,GACwC,iBAA/BL,KAAKoD,WAAW/C,GAAGkB,SAC1BvB,KAAKqJ,WAAW3I,EAAWV,KAAKoD,WAAW/C,GAAGkB,SAE9C,OAAO,EAIX,OAAO,EAGT8H,WAAW3I,EAAW0C,GACpB,IAAI/C,EAAI+C,EAAWhD,OAEnB,KAAOC,KAAK,CACV,GAAIK,IAAc0C,EAAW/C,GAAI,OAAO,EAExC,QACmC,IAA1B+C,EAAW/C,GAAGkB,SACrBvB,KAAKqJ,WAAW3I,EAAW0C,EAAW/C,GAAGkB,SAEzC,OAAO,EAGX,OAAO,GAgBX,IAAIgB,GAAS,EAoNb5C,EAAOsB,OAASA,EAChBtB,EAAOqD,UAAYA,EACnBrD,EAAO+D,OAnBP,WAEE,MAAMU,EAAOD,EAAYhE,WACzB,OACEuE,GAAIjE,GAAUwC,EAASwB,EAAYhE,GAAS2D,EAAKE,OAAQF,EAAKvC,WAgBlElC,EAAOuE,MAXP,SAAerC,GACb,MAAMyH,EAAOnF,MAAiBtC,IAAUA,QACxC,OACE6C,GAAIjE,GAAUwD,EAAQQ,EAAYhE,GAAS6I,KAS/C3J,EAAO4J,UApOP,SAAmBN,GAQjB,OAPAjJ,KAAKkC,QAAUjC,EAAcD,KAAKkC,QAAS+G,GAGN,iBAA1BA,EAAWhH,aACpBjC,KAAKkC,QAAQD,WAAagH,EAAWhH,YAGhCjC,MA8NTL,EAAO6J,OACL5I,SAAAA,EACAiE,WAAAA,EACAf,SAAAA,EACAvD,aAAAA,EACAN,cAAAA,GAEFN,EAAO8J,UACL/I,UAAWc,EACXO,WAAAA,EACAW,YAAAA,EACAO,SAAAA,EACAgB,QAAAA,EACA1B,OAAAA,EACA4B,YAAAA,EACAM,YAAAA,GAMF,MAAM+C,EAAkBvG,GACtBK,KAAM,kBACNoI,UAAW,gEACXC,SAAU,cACVC,kBAAmB,sBACnBC,KAAM,qCAIFhC,EACJ/G,YAAYH,GACVX,KAAKgI,QACLhI,KAAK8J,SAASnJ,GACdX,KAAKkI,QACLlI,KAAK+J,WAIPD,SAASnJ,GACP,IAAIgB,EAAQhB,EACZ,OAAa,CACX,GAAc,OAAVgB,EACF,MAGF,GAAIgB,EAAQC,KAAKjB,EAAMb,YAAa,iBAAkB,CACpD,MAAMiE,EAAUpD,EAAMb,YAAYC,cAAcqC,WAChDpD,KAAKgI,KAAKgC,SACRZ,gBAAiBzH,EAAMb,YAAYQ,KACnCK,MAAAA,EACAd,WAAYkE,IAIhBpD,EAAQf,EAASe,GAEnB,OAAO3B,KAAKgI,KAGd+B,WACE,MAAM7J,EAAMF,KAAKgI,KAAK5H,OACtB,IAAIC,GAAK,EAET,OAASA,EAAIH,GACXF,KAAKiK,QACHjK,KAAKgI,KAAK3H,GAAGsB,MACb3B,KAAKgI,KAAK3H,GAAGQ,WACbb,KAAKgI,KAAK3H,GAAG+I,iBACb,GAGJ,OAAOpJ,KAAKkI,KAGd+B,QAAQtI,EAAOyB,EAAYgG,EAAiBc,GAC1C,MAAMhK,EAAMkD,EAAWhD,OACvB,IAAIC,GAAK,EACT,OAASA,EAAIH,GAAK,CAChB,MAAMiK,EAAY/G,EAAW/C,GACvB+J,GAAShB,gBAAAA,EAAiBiB,oBAAqBH,EAAUvI,MAAAA,GAC/D,IAAI2I,EACA3D,EAAI3G,KAAKkI,KAAK9H,OAElB,KAAOuG,KACL,GAAI3G,KAAKkI,KAAKvB,GAAG4D,YAAcJ,EAAW,CACxCG,EAAStK,KAAKkI,KAAKvB,GACnB,WAGkB,IAAX2D,EACTtK,KAAKkI,KAAKvE,MAAO4G,UAAWJ,EAAWK,eAAgBJ,KAEvDE,EAAOE,cAAc7G,KAAKyG,QAGK,IAAtBD,EAAU5I,SACnBvB,KAAKiK,QAAQtI,EAAOwI,EAAU5I,QAAS6H,GAAiB,GAG5D,OAAOpJ,KAAKkI,KAGdH,gBACE,MAAM0C,KAEAvK,EAAMF,KAAKkI,KAAK9H,OACtB,IAAIC,GAAK,EACT,OAASA,EAAIH,GACPF,KAAKkI,KAAK7H,GAAGmK,cAAcpK,OAAS,GAAGqK,EAAQ9G,KAAK3D,KAAKkI,KAAK7H,IAGpE,OAAOoK,EAGTtC,UACE,OAAOnI,KAAKkI,KAGdD,UACE,OAAOjI,KAAKgI,MAsZhB,OAlZAzF,GACEhD,OAAQ,CAAC8D,EAAS1B,EAAOG,KACvBnC,EAAOuC,QAAQa,UAAUT,OACvBiD,UAAW,SACXlC,QAAAA,EACAQ,uBAAwBlC,EAAMb,YAAYQ,gDAC1CQ,MAAAA,EACA4I,YAAa/I,EAAMb,eAGvBkC,UAAW,CAACK,EAAS1B,EAAOG,KAC1B,MAAM6I,EAAgB,IAAI9C,EAAgBlG,GAAOwG,UACjDxI,EAAOuC,QAAQa,UAAUT,OACvBiD,UAAW,YACXlC,QAAAA,EACAQ,uBAAwBlC,EAAMb,YAC3BQ,oCAAoCK,EAAMb,YAAYC,cAAcqC,WACpEW,IAAIoG,GAAaA,EAAU7I,MAC3B0C,KAAK,cAAcrC,EAAMb,YAAYQ,oBAAoBqJ,EACzD5G,IAAI4E,GAAQA,EAAK4B,UAAUjJ,MAC3B0C,KAAK,QACRlC,MAAAA,EACA6I,cAAAA,EACAD,YAAa/I,EAAMb,eAGvB4C,OAAQ,CAACL,EAAS1B,EAAOoD,EAASzB,EAAYH,EAASD,KACrD,GAAII,EAAY,CACd,MAAMsH,KACAC,EAAiB,IAAIhD,EAAgBlG,GAAOwG,UAC5C2C,EAAUD,EAAezK,OAC/B,IAAIC,GAAK,EACT,OAASA,EAAIyK,GAAS,CACpB,MAAM5K,EAAM6E,EAAQ3E,OACpB,IAAIuG,GAAK,EACT,OAASA,EAAIzG,GACX,GAAI2K,EAAexK,GAAGkK,YAAcxF,EAAQ4B,GAAI,CAC9CiE,EAAWjH,KAAKkH,EAAexK,IAC/B,OAKN,MAAMsI,GACJpD,UAAW,SACXlC,QAAAA,EACAQ,uBAAwBlC,EAAMb,YAAYQ,SAAS6B,EAAQ/C,OAAS,sBAC5C+C,EAAQY,IAAIoG,GAAaA,EAAU7I,MAAM0C,KAAK,qBAClE,KACDd,EAAO9C,OAAS,sBACO8C,EACjBa,IAAIoG,GAAaA,EAAU7I,MAC3B0C,KAAK,0BAA0BrC,EAAMb,YAAYQ,8BACpD,KACHsJ,EAAWxK,OAAS,kBACDwK,EACb7G,IAAIgH,GAAkBA,EAAeR,UAAUjJ,MAC/C0C,KAAK,6EACR,MACNlC,MAAOiD,EACP2F,YAAa/I,EAAMb,YACnBqC,QAAAA,EACAD,OAAAA,EACA0H,WAAAA,EACA1C,KAAM2C,GAGRlL,EAAOuC,QAAQa,UAAUT,MAAMqG,QAE/BhJ,EAAOuC,QAAQa,UAAUT,OACvBiD,UAAW,SACXlC,QAAAA,EACAQ,uBAAwBlC,EAAMb,YAC3BQ,gFACHQ,MAAOiD,EACP2F,YAAa/I,EAAMb,eAIzBoD,MAAO,CAACb,EAAS1B,EAAOG,EAAOwB,KACzBA,EACF3D,EAAOuC,QAAQa,UAAUT,OACvBiD,UAAW,QACXlC,QAAAA,EACAQ,uBAAwBlC,EAAMb,YAAYQ,cAAc+B,EACpD,GACA,2BACJvB,MAAAA,EACA4I,YAAa/I,EAAMb,cAGrBnB,EAAOuC,QAAQa,UAAUT,OACvBiD,UAAW,QACXlC,SAAS,EACTQ,uBAAwBlC,EAAMb,YAC3BQ,6EACHQ,MAAAA,EACA4I,YAAa/I,EAAMb,eAIzB2F,cAAe,CAACpD,EAAS5C,EAAQyE,EAAOI,KACtC,MAAMqD,EAAOrD,EACP0F,EAAgC,mBAAXvK,EAC3BkI,EAAKtF,QAAUA,EACfsF,EAAK+B,YAAcM,EAAcvK,EAAOK,YAAcL,EACtDkI,EAAK9E,uBAAyB8E,EAAK+B,YAAYpJ,MAC5C0J,EAAc,aAAe,mBAAmBA,EAC/C9F,EAAMpE,YAAYQ,KAClB4D,EAAM5D,OAAS0J,EAAc,aAAe,kBAAkBrC,EAAKlD,YAAYrF,OAAS,+BAC3DuI,EAAKlD,YAAYzB,KAAK,QACnD,KAEJ2E,EAAK7G,MAAQoD,EACbvF,EAAOuC,QAAQa,UAAUT,MAAMqG,KAqRnChJ,EAAOsL,IAVP,WAEE,MAAM7G,EAAOD,EAAYhE,UAAW,SAEpC,OACEuE,GAAIjE,GAAUwG,EAAMxC,EAAYhE,GAAS2D,EAAKE,OAAQF,EAAKvC,WAM/DlC,EAAO2C,MApCP,SAAe4I,GACb,MAAMC,GAAc,aAAc,OAAQ,QAC1C,IAAI7G,EACJ,QAAsB,IAAX4G,EACT5G,EAAS6G,OACJ,GAAsB,iBAAXD,EAEd5G,EADa,QAAX4G,EACOC,GAECD,OAEP,CAAA,IAAI3G,MAAMC,QAAQ0G,GAGvB,MAAMzJ,yEAC2D0J,EAAWnH,KAAK,eAHjFM,EAAS4G,EAOX,OACExG,GAAIjE,GAAUgH,EAAQhD,EAAYhE,GAAS6D,KAkB/C3E,EAAOkB,YAAe2G,gBAAAA,GACtB7H,EAAO8J,SAAS5B,gBAAkBA,EAClClI,EAAO8J,SAASxC,MAAQA,EACxBtH,EAAO8J,SAAShC,QAAUA,EAC1B9H,EAAO8J,SAASlH,OAASA,EAIlB5C","file":"interf-es.min.js","sourcesContent":["/**\n * @license\n * Interf <https://shvabuk.github.io/interf>\n * Released under MIT license <https://shvabuk.github.io/interf/LICENSE.txt>\n * Copyright Shvab Ostap\n */\n;((root, factory) => {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node.\n    const interf = factory();\n    module.exports = interf;\n    // CommonJS exports\n    module.exports.interf = interf;\n  } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n    // CommonJS\n    exports.interf = factory();\n  } else if (typeof root.interf !== 'object' || !Number.isInteger(root.interf.VERSION)) {\n    root.interf = factory();\n  }\n})(this, () => {\n  \n  // ------------------------------------------------------------------------\n  // utils block start\n\n  // get object prototype\n  const getProto = Object.getPrototypeOf || (obj => obj.__proto__);\n  // add source array values to target array, source array values may be arguments object (is array like)\n  const addArray = (target, source) => {\n    const len = source.length;\n    let i = -1;\n    while (++i < len) {\n      target.push(source[i]);\n    }\n    return target;\n  };\n  // merge source object values in target object recursively, arrays merged by addArray\n  const mergeObjects = (target, source) => {\n    const destination = target;\n    const keys = Object.keys(source);\n    let i = keys.length;\n    while (i--) {\n      if (Array.isArray(source[keys[i]])) {\n        if (Array.isArray(destination[keys[i]])) {\n          // append array\n          destination[keys[i]] = addArray(destination[keys[i]], source[keys[i]]);\n        } else {\n          // create new array\n          destination[keys[i]] = addArray([], source[keys[i]]);\n        }\n      } else if (typeof source[keys[i]] === 'object') {\n        if (typeof destination[keys[i]] === 'object') {\n          // mutate destination[key]\n          destination[keys[i]] = mergeObjects(destination[keys[i]], source[keys[i]]);\n        } else {\n          // merge source[key] to new object\n          destination[keys[i]] = mergeObjects({}, source[keys[i]]);\n        }\n      } else {\n        destination[keys[i]] = source[keys[i]];\n      }\n    }\n\n    return destination;\n  };\n  // merge objects values in new obj, arrays merged\n  function assignObjects() {\n    const len = arguments.length;\n    let i = -1;\n    let ret = {};\n    while (++i < len) {\n      ret = mergeObjects(ret, arguments[i]);\n    }\n    return ret;\n  }\n\n  // get symbols, if method not provided, will return empty array, needed for getOwnPropsKeys\n  const getSymbols = Object.getOwnPropertySymbols || (() => []);\n\n  // utils block end\n  // ------------------------------------------------------------------------\n\n  // has own property check, usage: has.call(obj, 'propName');\n  const hasProp = Object.prototype.hasOwnProperty;\n\n  // main object\n  const interf = {\n    // integer count of all versions, current version: 1.0.0\n    VERSION: 1,\n    _config: {\n      // use interf.configure to set config values\n      warn: false,\n      debug: false, // ignored in core build\n      afterImplement: false,\n      descriptor: {\n        // value: (auto-defined, in case when setter is defined will be auto-assigned),\n        configurable: true,\n        writable: false,\n        enumerable: false,\n        // set: undefined,\n        // get: undefined,\n      },\n      callbacks: {\n        warn: function warnCallback(data) {\n          if (typeof console === 'object' && console.warn) console.warn(data.message);\n        },\n        // ignored in core build\n        debug: function debugCallback(data) {\n          if (typeof console === 'object' && console.log) console.log(data.message, data);\n        },\n        afterImplement: function afterImplementCallback(classInterfaces, Class, interfaces) {},\n      },\n      // ignored in core build\n      mixin: {\n        // warn: this.,\n        // debug: false,\n        createInit: true, // create initMixins method in target prototype\n        interfaces: true,\n        replace: true,\n        notConfigurableNotWritableError: true, // ignored if replace == false,\n        // https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\n        ignore: {\n          protoProps: [\n            'constructor',\n            'apply',\n            'bind',\n            'call',\n            'isGenerator',\n            'toSource',\n            'toString',\n            '__proto__',\n          ],\n          staticProps: [\n            'arguments',\n            'arity',\n            'caller',\n            'length',\n            'name',\n            'displayName',\n            'prototype',\n            '__proto__',\n          ],\n        },\n      },\n    },\n  };\n\n  const CAPITAL_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n  function parentHas(target, Interface) {\n    const prototype = getProto(target);\n    if (prototype === null) return false;\n    const interfaces = prototype.constructor.__interfaces_;\n    if (typeof interfaces !== 'undefined' && interfaces.has(Interface)) return true;\n    return parentHas(prototype, Interface);\n  }\n\n  // Base interface class\n  const InterfaceClass = class Interface {\n    constructor(properties) {\n      if (typeof properties.extends !== 'undefined' && !Array.isArray(properties.extends)) {\n        throw TypeError('Interface extends should be an Array');\n      }\n      if (typeof properties.name === 'string' && properties.name.length !== 0) {\n        const keys = Object.keys(properties);\n        let i = keys.length;\n        // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n        while (i--) {\n          if (\n            CAPITAL_CHARS.indexOf(keys[i][0]) > -1 ||\n            keys[i] === 'name' ||\n            keys[i] === 'extends'\n          ) {\n            this[keys[i]] = properties[keys[i]];\n          } else {\n            throw Error('Interface optional property name should start with capital letter');\n          }\n        }\n      } else {\n        throw TypeError('Interface should have a name');\n      }\n    }\n\n    isInterfaceOf(object) {\n      // code repeating here, same as in parentHas()\n      // those solulution works faster than just using of parentHas()\n      // TODO: check in others environments\n      const prototype = getProto(object);\n      if (prototype === null) return false;\n      const interfaces = prototype.constructor.__interfaces_;\n      if (typeof interfaces !== 'undefined' && interfaces.has(this)) return true;\n      return parentHas(prototype, this);\n    }\n  };\n\n  // interf.create(), create Interface\n  function create(interfaceName, extendsArray) {\n    // no need in rest args (...args), also minimize code (babel will transform it\n    // to arguments anyway)\n    const ar = arguments;\n    if (typeof ar[0] === 'string') {\n      const obj = { name: ar[0] };\n      if (typeof ar[1] !== 'undefined') obj.extends = ar[1];\n      return new InterfaceClass(obj);\n    } else if (typeof ar[0] === 'object') {\n      return new InterfaceClass(ar[0]);\n    }\n    throw TypeError(\n      'In method interf.create first parameter should be an object or Interface name'\n    );\n  }\n\n  // Interfaces objects are stored in __interfaces_\n  class Interfaces {\n    constructor(version) {\n      this.collection = [];\n      this.VERSION = version;\n    }\n\n    // add only unique, but not unique in extends or parent\n    // mainly incoming parameter will be arguments object (array like)\n    add(interfaces, constructorName) {\n      const len = interfaces.length;\n      let i = -1;\n      while (++i < len) {\n        let j = this.collection.length;\n        // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n        while (j--) {\n          if (this.collection[j] === interfaces[i]) {\n            throw Error(\n              `Class ${constructorName} cannot implement previously implemented interface ${interfaces[\n                i\n              ].name}`\n            );\n          }\n        }\n\n        this.collection.push(interfaces[i]);\n      }\n      return this;\n    }\n\n    remove(Interface) {\n      let i = this.collection.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        if (Interface === this.collection[i]) {\n          this.collection.splice(i, 1);\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // check instance interfaces\n    // comparison is fastest solution\n    has(Interface) {\n      let i = this.collection.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        if (Interface === this.collection[i]) return true;\n        // check extended interfaces\n        if (\n          typeof this.collection[i].extends === 'object' &&\n          this.extendsHas(Interface, this.collection[i].extends)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    extendsHas(Interface, collection) {\n      let i = collection.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        if (Interface === collection[i]) return true;\n        // check extended interfaces\n        if (\n          typeof collection[i].extends !== 'undefined' &&\n          this.extendsHas(Interface, collection[i].extends)\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function configure(properties) {\n    this._config = assignObjects(this._config, properties);\n\n    // descriptor should be rewrited\n    if (typeof properties.descriptor === 'object') {\n      this._config.descriptor = properties.descriptor;\n    }\n\n    return this;\n  }\n\n  // debug information computing functions\n  let debugs = false;\n\n  // define __interfaces_ in prototype\n  function defineInterfacesProp(proto, parent, options) {\n    const value = new Interfaces(interf.version, parent);\n    const descriptor = assignObjects(options.descriptor); // assign to empty object {}\n\n    if (typeof interf._config.descriptor.set !== 'function') {\n      descriptor.value = value;\n    }\n\n    Object.defineProperty(proto.constructor, '__interfaces_', descriptor);\n    if (typeof descriptor.set === 'function') {\n      proto.constructor.__interfaces_ = value;\n    }\n\n    if (options.debug && debugs) debugs.define(true, proto, value);\n  }\n\n  function validateInterfaces(interfaces) {\n    let i = interfaces.length;\n    while (i--) {\n      if (typeof interfaces[i] !== 'object') {\n        throw TypeError(`Undefined type ${typeof interfaces[i]} of interface`);\n      } else if (typeof interfaces[i].isInterfaceOf !== 'function') {\n        throw TypeError(`Undefined type of interface: ${interfaces[i].name}`);\n      }\n    }\n  }\n\n  // implement interface function\n  function implementIn(prototype, interfaces, options) {\n    validateInterfaces(interfaces);\n\n    const constructor = prototype.constructor;\n\n    if (!hasProp.call(constructor, '__interfaces_')) {\n      defineInterfacesProp(prototype, null, options);\n    }\n\n    // add intefaces to prototype\n    constructor.__interfaces_.add(interfaces, constructor.name);\n\n    if (interf._config.afterImplement) {\n      interf._config.callbacks.afterImplement(constructor.__interfaces_, constructor, interfaces);\n    }\n\n    if (options.debug && debugs) debugs.implement(true, prototype, interfaces);\n\n    return constructor;\n  }\n\n  // remove function\n  function removeIn(prototype, interfaces, options) {\n    validateInterfaces(interfaces);\n\n    const constructor = prototype.constructor;\n    const missed = [];\n    const deleted = [];\n    let collection;\n    let success = false;\n    let interfaced = false;\n    if (hasProp.call(constructor, '__interfaces_')) {\n      collection = constructor.__interfaces_.collection;\n\n      let i = interfaces.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        const index = collection.indexOf(interfaces[i]);\n        let warnMsg = '';\n\n        if (index > -1) {\n          if (constructor.__interfaces_.remove(interfaces[i])) {\n            deleted.push(interfaces[i]);\n\n            if (constructor.__interfaces_.has(interfaces[i])) {\n              warnMsg = `removed, but interface still exist in other interfaces parents.`;\n            }\n\n            if (parentHas(prototype, interfaces[i])) {\n              warnMsg += ` removed, but interface still exist in parents prototypes constructors interfaces.`;\n            }\n          } else {\n            warnMsg = `not removed from own interfaces.`;\n          }\n        } else {\n          warnMsg = `not found in own interfaces.`;\n\n          missed.push(interfaces[i]);\n        }\n\n        if (options.warn && warnMsg.length > 0) {\n          interf._config.callbacks.warn({\n            message: `Constructor ${constructor.name}. Interface ${interfaces[i]\n              .name} was ${warnMsg}`,\n          });\n        }\n      }\n\n      success = deleted.length === interfaces.length;\n\n      interfaced = true;\n    } else if (options.warn) {\n      interf._config.callbacks.warn({\n        message: `Constructor ${constructor.name} none interface was found. Interfaces ${addArray(\n          [],\n          interfaces\n        )\n          .map(Interface => Interface.name)\n          .join(', ')} was not removed from own interfaces.`,\n      });\n    }\n\n    if (options.debug && debugs) {\n      debugs.remove(success, prototype, interfaces, interfaced, deleted, missed);\n    }\n\n    return success;\n  }\n\n  // empty function\n  function emptyIn(prototype, options) {\n    const constructor = prototype.constructor;\n    let success = false;\n    let interfaced = false;\n    if (hasProp.call(constructor, '__interfaces_')) {\n      // create new array\n      const interfaces = addArray([], constructor.__interfaces_.collection);\n      if (interfaces.length !== 0) {\n        success = removeIn(prototype, interfaces, options);\n      }\n\n      interfaced = true;\n    }\n\n    if (options.debug && debugs) debugs.empty(success, prototype, null, interfaced);\n\n    return success;\n  }\n\n  // resolve input arguments\n  function resolveArgs(args, section) {\n    const ret = { values: args, options: {} };\n    let descriptor;\n    if (Array.isArray(args[0])) {\n      ret.values = args[0];\n      if (typeof args[1] === 'object') {\n        ret.options = args[1];\n        if (typeof ret.options.descriptor === 'object') {\n          descriptor = ret.options.descriptor;\n        }\n      }\n    }\n\n    if (typeof section === 'string') {\n      ret.options = assignObjects(interf._config, interf._config[section], ret.options);\n    } else {\n      ret.options = assignObjects(interf._config, ret.options);\n    }\n\n    // special rule for descriptor option\n    // descriptor should be rewrited\n    if (typeof descriptor !== 'undefined') {\n      ret.options.descriptor = descriptor;\n    }\n\n    return ret;\n  }\n\n  // get proto of given in \".in(target)\" method argument\n  function targetProto(target) {\n    if (typeof target === 'function') {\n      return target.prototype;\n    } else if (\n      // check is protolike object\n      typeof target.constructor === 'function' &&\n      target.constructor.prototype === target\n    ) {\n      return target;\n    }\n    throw TypeError(\n      `Wrong target, should be function (class) or prototype of function (class). Current value: ${target}.`\n    );\n  }\n\n  // interf.implement()\n  function implement() {\n    // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n    const args = resolveArgs(arguments);\n    return {\n      in: target => implementIn(targetProto(target), args.values, args.options),\n    };\n  }\n\n  // interf.remove()\n  function remove() {\n    // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n    const args = resolveArgs(arguments);\n    return {\n      in: target => removeIn(targetProto(target), args.values, args.options),\n    };\n  }\n\n  // interf.empty()\n  function empty(options) {\n    const opts = resolveArgs([[], options]).options;\n    return {\n      in: target => emptyIn(targetProto(target), opts),\n    };\n  }\n\n  // core\n  interf.create = create;\n  interf.implement = implement;\n  interf.remove = remove;\n  interf.empty = empty;\n  interf.configure = configure;\n  // core additional\n  interf.utils = {\n    getProto,\n    getSymbols,\n    addArray,\n    mergeObjects,\n    assignObjects,\n  };\n  interf.internal = {\n    Interface: InterfaceClass,\n    Interfaces,\n    implementIn,\n    removeIn,\n    emptyIn,\n    debugs,\n    resolveArgs,\n    targetProto,\n  };\n\n  // @NOT_CORE_BEGIN@\n\n  // Interface for objects mixined with classes with constructor method, and mark that initMixins method are able\n  const MixinsInitiable = create({\n    name: 'MixinsInitiable',\n    Comments: ['Class with this interface may init values provided by mixins'],\n    Methods: ['initMixins'],\n    StaticProperties: ['__mixins_: class[]'],\n    Docs: '//shvabuk.github.io/interf',\n  });\n\n  // class for getting debug information\n  class DebugInterfaces {\n    constructor(prototype) {\n      this.tree = [];\n      this.initTree(prototype);\n      this.list = [];\n      this.initList();\n    }\n\n    // use proto chain here because we need proto info, that may not provided by parent property\n    initTree(prototype) {\n      let proto = prototype;\n      while (true) {\n        if (proto === null) {\n          break;\n        }\n\n        if (hasProp.call(proto.constructor, '__interfaces_')) {\n          const interfs = proto.constructor.__interfaces_.collection;\n          this.tree.unshift({\n            constructorName: proto.constructor.name,\n            proto,\n            interfaces: interfs,\n          });\n        }\n\n        proto = getProto(proto);\n      }\n      return this.tree;\n    }\n\n    initList() {\n      const len = this.tree.length;\n      let i = -1;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (++i < len) {\n        this.addInfo(\n          this.tree[i].proto,\n          this.tree[i].interfaces,\n          this.tree[i].constructorName,\n          false\n        );\n      }\n      return this.list;\n    }\n\n    addInfo(proto, collection, constructorName, extended) {\n      const len = collection.length;\n      let i = -1;\n      while (++i < len) {\n        const InterFace = collection[i];\n        const info = { constructorName, asExtendedInterface: extended, proto };\n        let result;\n        let j = this.list.length;\n        // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n        while (j--) {\n          if (this.list[j].interface === InterFace) {\n            result = this.list[j];\n            break;\n          }\n        }\n        if (typeof result === 'undefined') {\n          this.list.push({ interface: InterFace, implementedIn: [info] });\n        } else {\n          result.implementedIn.push(info);\n        }\n\n        if (typeof InterFace.extends !== 'undefined') {\n          this.addInfo(proto, InterFace.extends, constructorName, true);\n        }\n      }\n      return this.list;\n    }\n\n    getDuplicates() {\n      const results = [];\n\n      const len = this.list.length;\n      let i = -1;\n      while (++i < len) {\n        if (this.list[i].implementedIn.length > 1) results.push(this.list[i]);\n      }\n\n      return results;\n    }\n\n    getList() {\n      return this.list;\n    }\n\n    getTree() {\n      return this.tree;\n    }\n  }\n\n  debugs = {\n    define: (success, proto, value) => {\n      interf._config.callbacks.debug({\n        operation: 'define',\n        success,\n        message: `Constructor ${proto.constructor.name} prototype property __interfaces_ defined`,\n        value,\n        Constructor: proto.constructor,\n      });\n    },\n    implement: (success, proto, value) => {\n      const allInterfaces = new DebugInterfaces(proto).getList();\n      interf._config.callbacks.debug({\n        operation: 'implement',\n        success,\n        message: `Constructor ${proto.constructor\n          .name} implemented own interfaces: ${proto.constructor.__interfaces_.collection\n          .map(InterFace => InterFace.name)\n          .join(', ')}. All ${proto.constructor.name} interfaces: ${allInterfaces\n          .map(data => data.interface.name)\n          .join(', ')}`,\n        value,\n        allInterfaces,\n        Constructor: proto.constructor,\n      });\n    },\n    remove: (success, proto, interfs, interfaced, deleted, missed) => {\n      if (interfaced) {\n        const stillExist = [];\n        const interfacesList = new DebugInterfaces(proto).getList();\n        const listLen = interfacesList.length;\n        let i = -1;\n        while (++i < listLen) {\n          const len = interfs.length;\n          let j = -1;\n          while (++j < len) {\n            if (interfacesList[i].interface === interfs[j]) {\n              stillExist.push(interfacesList[i]);\n              break;\n            }\n          }\n        }\n\n        const data = {\n          operation: 'remove',\n          success,\n          message: `Constructor ${proto.constructor.name}.${(deleted.length > 0\n            ? ` Own interfaces: ${deleted.map(InterFace => InterFace.name).join(', ')} was deleted.`\n            : '') +\n            (missed.length > 0\n              ? ` Own interfaces: ${missed\n                  .map(InterFace => InterFace.name)\n                  .join(', ')} was not found in ${proto.constructor.name} interfaces collection.`\n              : '') +\n            (stillExist.length > 0\n              ? ` Interfaces: ${stillExist\n                  .map(listednterface => listednterface.interface.name)\n                  .join(', ')} still exist in parents constructor prototypes or parents interfaces.`\n              : '')}`,\n          value: interfs,\n          Constructor: proto.constructor,\n          deleted,\n          missed,\n          stillExist,\n          list: interfacesList,\n        };\n\n        interf._config.callbacks.debug(data);\n      } else {\n        interf._config.callbacks.debug({\n          operation: 'remove',\n          success,\n          message: `Constructor ${proto.constructor\n            .name} does not implement interf interfaces. Interface removing is not possible`,\n          value: interfs,\n          Constructor: proto.constructor,\n        });\n      }\n    },\n    empty: (success, proto, value, interfaced) => {\n      if (interfaced) {\n        interf._config.callbacks.debug({\n          operation: 'empty',\n          success,\n          message: `Constructor ${proto.constructor.name} empty ${success\n            ? ''\n            : 'not '}all own interfaces`,\n          value,\n          Constructor: proto.constructor,\n        });\n      } else {\n        interf._config.callbacks.debug({\n          operation: 'empty',\n          success: false,\n          message: `Constructor ${proto.constructor\n            .name} does not implement interf interfaces. Interface empty is not possible`,\n          value,\n          Constructor: proto.constructor,\n        });\n      }\n    },\n    mixProperties: (success, target, mixin, debugData) => {\n      const data = debugData;\n      const isPrototype = typeof target !== 'function';\n      data.success = success;\n      data.Constructor = isPrototype ? target.constructor : target;\n      data.message = `Constructor ${data.Constructor.name +\n        (isPrototype ? ' prototype' : '')} mixed with ${(isPrototype\n        ? mixin.constructor.name\n        : mixin.name) + (isPrototype ? ' prototype' : '')} properties.${data.notReplaced.length > 0\n        ? ` Not replaced properties: ${data.notReplaced.join(', ')}`\n        : ''}`;\n\n      data.value = mixin;\n      interf._config.callbacks.debug(data);\n    },\n  };\n\n  // get props names, used in mixin\n  function getOwnPropsKeys(target) {\n    return addArray(Object.getOwnPropertyNames(target), getSymbols(target));\n  }\n\n  function implementByMixIn(target, interfaces, options) {\n    const prototype = targetProto(target);\n    // create new array, transform arguments to array\n    const interfs = addArray([], interfaces);\n\n    let i = interfs.length;\n    // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n    while (i--) {\n      // ignore duplicates\n      if (\n        hasProp.call(prototype.constructor, '__interfaces_') &&\n        prototype.constructor.__interfaces_.collection.indexOf(interfs[i]) > -1\n      ) {\n        interfs.splice(i, 1);\n      }\n    }\n\n    return implementIn(prototype, interfs, options);\n  }\n\n  // define mixin (constructor or prototype) properties\n  function defineProps(target, mixin, options, ignore) {\n    const mixinNames = getOwnPropsKeys(mixin);\n    const targetNames = getOwnPropsKeys(target);\n    const debugData = {\n      operation: 'mixProperties',\n      target,\n      mixin,\n      ignoredNames: [],\n      notReplaced: [],\n      replaced: [],\n      defined: [],\n      writed: [],\n    };\n\n    let i = mixinNames.length;\n    // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n    while (i--) {\n      // ignore props from ignorelist\n      if (ignore.indexOf(mixinNames[i]) > -1) {\n        if (options.debug) debugData.ignoredNames.push(mixinNames[i]);\n        continue;\n      }\n      // implement interfaces\n      if (mixinNames[i] === '__interfaces_') {\n        if (options.interfaces) {\n          implementByMixIn(target, mixin.__interfaces_.collection, options);\n          if (options.debug) debugData.interfaces = mixin.__interfaces_.collection;\n        }\n        continue;\n      }\n\n      const descriptor = Object.getOwnPropertyDescriptor(mixin, mixinNames[i]);\n      // check prop name in target\n      if (targetNames.indexOf(mixinNames[i]) > -1) {\n        // add mixins constructors if exists\n        if (mixinNames[i] === '__mixins_') {\n          addArray(target.__mixins_, mixin.__mixins_);\n          if (options.debug) debugData.mixins = mixin.__mixins_;\n        } else {\n          const isProto = typeof target === 'object';\n\n          if (options.warn) {\n            interf._config.callbacks.warn({\n              message: `Target ${isProto\n                ? `${target.constructor.name} prototype`\n                : target.name} alredy have mixin (${isProto\n                ? `${mixin.constructor.name} prototype`\n                : mixin.name}) property \"${mixinNames[i]}\". Will be ${options.replace\n                ? 'replaced'\n                : 'ignored'}.`,\n            });\n          }\n\n          if (options.replace) {\n            // resolve conflicts\n            const targetDescriptor = Object.getOwnPropertyDescriptor(target, mixinNames[i]);\n            if (!targetDescriptor.configurable) {\n              if (targetDescriptor.writable) {\n                // write property\n                target[mixinNames[i]] = mixin[mixinNames[i]];\n                if (options.debug) debugData.writed.push(mixinNames[i]);\n              } else if (options.notConfigurableNotWritableError) {\n                try {\n                  // show some additional info\n                  console.error(\n                    'Trying to define not configurable and not writable value. Interf mixin debug info',\n                    debugData\n                  );\n                } catch (e) {}\n                // force error throwing\n                Object.defineProperty(target, mixinNames[i], descriptor);\n              } else {\n                // ignore if options.notConfigurableNotWritableError = false and targetDescriptor.configurable true\n                if (options.debug) debugData.notReplaced.push(mixinNames[i]);\n                if (options.warn) {\n                  interf._config.callbacks.warn({\n                    message: `Mixin ${isProto\n                      ? `${mixin.constructor.name} prototype`\n                      : mixin.name} property \"${mixinNames[\n                      i\n                    ]}\" ignored, because is not writable and not configurable`,\n                  });\n                }\n              }\n            } else {\n              // replace value\n              Object.defineProperty(target, mixinNames[i], descriptor);\n              if (options.debug) debugData.replaced.push(mixinNames[i]);\n            }\n          } else if (options.debug) {\n            // ignore if options.replace == false\n            debugData.notReplaced.push(mixinNames[i]);\n          }\n        }\n      } else {\n        // define property\n        Object.defineProperty(target, mixinNames[i], descriptor);\n        if (options.debug) debugData.defined.push(mixinNames[i]);\n      }\n    }\n\n    if (options.debug && debugs) debugs.mixProperties(true, target, mixin, debugData);\n  }\n\n  // return initMixins function, MixinsInitiable objects method\n  // may be used if interf._config.mixin.createInit or options.createInit is true\n  function createInitMixins(replace) {\n    return function initMixins() {\n      // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n      let prototype = getProto(this);\n      while (true) {\n        if (prototype === null) {\n          break;\n        }\n\n        if (hasProp.call(prototype.constructor, '__mixins_')) {\n          const length = prototype.constructor.__mixins_.length;\n          let j = -1;\n          while (++j < length) {\n            // const mixinObject = new prototype.constructor.__mixins_[j](...args);\n            // compiled by babel\n            const mixinObject = new (Function.prototype.bind.apply(\n              prototype.constructor.__mixins_[j],\n              addArray([null], arguments)\n            ))();\n            const keys = Object.keys(mixinObject);\n            let i = keys.length;\n            // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n            while (i--) {\n              if (typeof this[keys[i]] === 'undefined' || replace) {\n                this[keys[i]] = mixinObject[keys[i]];\n              }\n            }\n          }\n        }\n\n        prototype = getProto(prototype);\n      }\n    };\n  }\n\n  // mixin function\n  function mixIn(targetPrototype, mixins, options) {\n    const mixinsConstructors = [];\n    const len = mixins.length;\n    let i = -1;\n    while (++i < len) {\n      const mixinProto = targetProto(mixins[i]);\n      defineProps(targetPrototype, mixinProto, options, options.ignore.protoProps);\n      defineProps(\n        targetPrototype.constructor,\n        mixinProto.constructor,\n        options,\n        options.ignore.staticProps\n      );\n      if (options.createInit) mixinsConstructors.push(mixinProto.constructor);\n    }\n\n    if (options.createInit) {\n      if (\n        typeof targetPrototype.__interfaces_ === 'undefined' ||\n        !targetPrototype.__interfaces_.has(MixinsInitiable)\n      ) {\n        Object.defineProperty(targetPrototype, 'initMixins', {\n          configurable: true,\n          writable: true,\n          value: createInitMixins(!!options.replace), // always convert replace to primitive\n        });\n\n        if (\n          typeof targetPrototype.constructor.__interfaces_ !== 'object' ||\n          targetPrototype.constructor.__interfaces_.collection.indexOf(MixinsInitiable) === -1\n        ) {\n          implement(MixinsInitiable).in(targetPrototype);\n        }\n      }\n\n      if (hasProp.call(targetPrototype.constructor, '__mixins_')) {\n        addArray(targetPrototype.constructor.__mixins_, mixinsConstructors);\n      } else {\n        Object.defineProperty(targetPrototype.constructor, '__mixins_', {\n          configurable: true,\n          writable: true,\n          value: mixinsConstructors,\n        });\n      }\n    }\n\n    return targetPrototype.constructor;\n  }\n\n  // debug function\n  function debugIn(prototype, actions) {\n    const information = {};\n    let i = actions.length;\n    const debugInfo = new DebugInterfaces(prototype);\n\n    // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n    while (i--) {\n      if (actions[i] === 'duplicates') {\n        information.duplicates = debugInfo.getDuplicates();\n      } else if (actions[i] === 'tree') {\n        information.tree = debugInfo.getTree();\n      } else if (actions[i] === 'list') {\n        information.list = debugInfo.getList();\n      }\n    }\n\n    return information;\n  }\n\n  // interf.debug() resolve given arguments and run debug\n  function debug(action) {\n    const allActions = ['duplicates', 'tree', 'list'];\n    let values;\n    if (typeof action === 'undefined') {\n      values = allActions;\n    } else if (typeof action === 'string') {\n      if (action === 'all') {\n        values = allActions;\n      } else {\n        values = [action];\n      }\n    } else if (Array.isArray(action)) {\n      values = action;\n    } else {\n      throw TypeError(\n        `debug first argument should be undefined, array, or string (${allActions.join(', ')}, all)`\n      );\n    }\n\n    return {\n      in: target => debugIn(targetProto(target), values),\n    };\n  }\n\n  // interf.mix()\n  function mix() {\n    // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n    const args = resolveArgs(arguments, 'mixin');\n\n    return {\n      in: target => mixIn(targetProto(target), args.values, args.options),\n    };\n  }\n\n  // full\n  interf.mix = mix;\n  interf.debug = debug;\n  // additional\n  interf.interfaces = { MixinsInitiable };\n  interf.internal.DebugInterfaces = DebugInterfaces;\n  interf.internal.mixIn = mixIn;\n  interf.internal.debugIn = debugIn;\n  interf.internal.debugs = debugs;\n\n  // @NOT_CORE_END@\n\n  return interf;\n});\n"]}