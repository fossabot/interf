/**
 * @license
 * Interf <https://shvabuk.github.io/interf>
 * Released under MIT license <https://shvabuk.github.io/interf/LICENSE.txt>
 * Copyright Shvab Ostap
 */
;((e,t)=>{if("function"==typeof define&&define.amd)define([],t);else if("object"==typeof module&&module.exports){const e=t();module.exports=e,module.exports.interf=e}else"object"==typeof exports&&"string"!=typeof exports.nodeName?exports.interf=t():"object"==typeof e.interf&&Number.isInteger(e.interf.VERSION)||(e.interf=t())})(this,()=>{function e(){const e=arguments.length;let t=-1,n={};for(;++t<e;)n=u(n,arguments[t]);return n}function t(e,n){const o=a(e);if(null===o)return!1;const r=o.constructor.__interfaces_;return!(void 0===r||!r.has(n))||t(o,n)}function n(t,n,o){const r=new g(m.version,n),s=e(o.descriptor);"function"!=typeof m._config.descriptor.set&&(s.value=r),Object.defineProperty(t.constructor,"__interfaces_",s),"function"==typeof s.set&&(t.constructor.__interfaces_=r),o.debug&&_&&_.define(!0,t,r)}function o(e){let t=e.length;for(;t--;){if("object"!=typeof e[t])throw TypeError(`Undefined type ${typeof e[t]} of interface`);if("function"!=typeof e[t].isInterfaceOf)throw TypeError(`Undefined type of interface: ${e[t].name}`)}}function r(e,t,r){o(t);const s=e.constructor;return d.call(s,"__interfaces_")||n(e,null,r),s.__interfaces_.add(t,s.name),m._config.afterImplement&&m._config.callbacks.afterImplement(s.__interfaces_,s,t),r.debug&&_&&_.implement(!0,e,t),s}function s(e,n,r){o(n);const s=e.constructor,c=[],i=[];let f,a=!1,u=!1;if(d.call(s,"__interfaces_")){f=s.__interfaces_.collection;let o=n.length;for(;o--;){const a=f.indexOf(n[o]);let l="";a>-1?s.__interfaces_.remove(n[o])?(i.push(n[o]),s.__interfaces_.has(n[o])&&(l=`removed, but interface still exist in other interfaces parents.`),t(e,n[o])&&(l+=` removed, but interface still exist in parents prototypes constructors interfaces.`)):l=`not removed from own interfaces.`:(l=`not found in own interfaces.`,c.push(n[o])),r.warn&&l.length>0&&m._config.callbacks.warn({message:`Constructor ${s.name}. Interface ${n[o].name} was ${l}`})}a=i.length===n.length,u=!0}else r.warn&&m._config.callbacks.warn({message:`Constructor ${s.name} none interface was found. Interfaces ${l([],n).map(e=>e.name).join(", ")} was not removed from own interfaces.`});return r.debug&&_&&_.remove(a,e,n,u,i,c),a}function c(e,t){const n=e.constructor;let o=!1,r=!1;if(d.call(n,"__interfaces_")){const c=l([],n.__interfaces_.collection);0!==c.length&&(o=s(e,c,t)),r=!0}return t.debug&&_&&_.empty(o,e,null,r),o}function i(t,n){const o={values:t,options:{}};let r;return Array.isArray(t[0])&&(o.values=t[0],"object"==typeof t[1]&&(o.options=t[1],"object"==typeof o.options.descriptor&&(r=o.options.descriptor))),o.options="string"==typeof n?e(m._config,m._config[n],o.options):e(m._config,o.options),void 0!==r&&(o.options.descriptor=r),o}function f(e){if("function"==typeof e)return e.prototype;if("function"==typeof e.constructor&&e.constructor.prototype===e)return e;throw TypeError(`Wrong target, should be function (class) or prototype of function (class). Current value: ${e}.`)}const a=Object.getPrototypeOf||(e=>e.__proto__),l=(e,t)=>{const n=t.length;let o=-1;for(;++o<n;)e.push(t[o]);return e},u=(e,t)=>{const n=e,o=Object.keys(t);let r=o.length;for(;r--;)Array.isArray(t[o[r]])?Array.isArray(n[o[r]])?n[o[r]]=l(n[o[r]],t[o[r]]):n[o[r]]=l([],t[o[r]]):"object"==typeof t[o[r]]?"object"==typeof n[o[r]]?n[o[r]]=u(n[o[r]],t[o[r]]):n[o[r]]=u({},t[o[r]]):n[o[r]]=t[o[r]];return n},p=Object.getOwnPropertySymbols||(()=>[]),d=Object.prototype.hasOwnProperty,m={VERSION:1,_config:{warn:!1,debug:!1,afterImplement:!1,descriptor:{configurable:!0,writable:!1,enumerable:!1},callbacks:{warn:function(e){"object"==typeof console&&console.warn&&console.warn(e.message)},debug:function(e){"object"==typeof console&&console.log&&console.log(e.message,e)},afterImplement:function(e,t,n){}},mixin:{createInit:!0,interfaces:!0,replace:!0,notConfigurableNotWritableError:!0,ignore:{protoProps:["constructor","apply","bind","call","isGenerator","toSource","toString","__proto__"],staticProps:["arguments","arity","caller","length","name","displayName","prototype","__proto__"]}}}},h="ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""),y=class{constructor(e){if(void 0!==e.extends&&!Array.isArray(e.extends))throw TypeError("Interface extends should be an Array");if("string"!=typeof e.name||0===e.name.length)throw TypeError("Interface should have a name");{const t=Object.keys(e);let n=t.length;for(;n--;){if(!(h.indexOf(t[n][0])>-1||"name"===t[n]||"extends"===t[n]))throw Error("Interface optional property name should start with capital letter");this[t[n]]=e[t[n]]}}}isInterfaceOf(e){const n=a(e);if(null===n)return!1;const o=n.constructor.__interfaces_;return!(void 0===o||!o.has(this))||t(n,this)}};class g{constructor(e){this.collection=[],this.VERSION=e}add(e,t){const n=e.length;let o=-1;for(;++o<n;){let n=this.collection.length;for(;n--;)if(this.collection[n]===e[o])throw Error(`Class ${t} cannot implement previously implemented interface ${e[o].name}`);this.collection.push(e[o])}return this}remove(e){let t=this.collection.length;for(;t--;)if(e===this.collection[t])return this.collection.splice(t,1),!0;return!1}has(e){let t=this.collection.length;for(;t--;){if(e===this.collection[t])return!0;if("object"==typeof this.collection[t].extends&&this.extendsHas(e,this.collection[t].extends))return!0}return!1}extendsHas(e,t){let n=t.length;for(;n--;){if(e===t[n])return!0;if(void 0!==t[n].extends&&this.extendsHas(e,t[n].extends))return!0}return!1}}let _=!1;return m.create=function(e,t){const n=arguments;if("string"==typeof n[0]){const e={name:n[0]};return void 0!==n[1]&&(e.extends=n[1]),new y(e)}if("object"==typeof n[0])return new y(n[0]);throw TypeError("In method interf.create first parameter should be an object or Interface name")},m.implement=function(){const e=i(arguments);return{in:t=>r(f(t),e.values,e.options)}},m.remove=function(){const e=i(arguments);return{in:t=>s(f(t),e.values,e.options)}},m.empty=function(e){const t=i([[],e]).options;return{in:e=>c(f(e),t)}},m.configure=function(t){return this._config=e(this._config,t),"object"==typeof t.descriptor&&(this._config.descriptor=t.descriptor),this},m.utils={getProto:a,getSymbols:p,addArray:l,mergeObjects:u,assignObjects:e},m.internal={Interface:y,Interfaces:g,implementIn:r,removeIn:s,emptyIn:c,debugs:_,resolveArgs:i,targetProto:f},m});
//# sourceMappingURL=interf-es-core.min.js.map
