/**
 * @license
 * Interf <https://shvabuk.github.io/interf>
 * Released under MIT license <https://shvabuk.github.io/interf/LICENSE.txt>
 * Copyright Shvab Ostap
 */
;((e,t)=>{if("function"==typeof define&&define.amd)define([],t);else if("object"==typeof module&&module.exports){const e=t();module.exports=e,module.exports.interf=e}else"object"==typeof exports&&"string"!=typeof exports.nodeName?exports.interf=t():"object"==typeof e.interf&&Number.isInteger(e.interf.VERSION)||(e.interf=t())})(this,()=>{function e(){const e=arguments.length;let t=-1,n={};for(;++t<e;)n=y(n,arguments[t]);return n}function t(e,n){const r=h(e);if(null===r)return!1;const o=r.constructor.__interfaces_;return!(void 0===o||!o.has(n))||t(r,n)}function n(e,t){const n=arguments;if("string"==typeof n[0]){const e={name:n[0]};return void 0!==n[1]&&(e.extends=n[1]),new j(e)}if("object"==typeof n[0])return new j(n[0]);throw TypeError("In method interf.create first parameter should be an object or Interface name")}function r(t,n,r){const o=new $(v.version,n),s=e(r.descriptor);"function"!=typeof v._config.descriptor.set&&(s.value=o),Object.defineProperty(t.constructor,"__interfaces_",s),"function"==typeof s.set&&(t.constructor.__interfaces_=o),r.debug&&O&&O.define(!0,t,o)}function o(e){let t=e.length;for(;t--;){if("object"!=typeof e[t])throw TypeError(`Undefined type ${typeof e[t]} of interface`);if("function"!=typeof e[t].isInterfaceOf)throw TypeError(`Undefined type of interface: ${e[t].name}`)}}function s(e,t,n){o(t);const s=e.constructor;return w.call(s,"__interfaces_")||r(e,null,n),s.__interfaces_.add(t,s.name),v._config.afterImplement&&v._config.callbacks.afterImplement(s.__interfaces_,s,t),n.debug&&O&&O.implement(!0,e,t),s}function i(e,n,r){o(n);const s=e.constructor,i=[],c=[];let a,l=!1,f=!1;if(w.call(s,"__interfaces_")){a=s.__interfaces_.collection;let o=n.length;for(;o--;){const l=a.indexOf(n[o]);let f="";l>-1?s.__interfaces_.remove(n[o])?(c.push(n[o]),s.__interfaces_.has(n[o])&&(f=`removed, but interface still exist in other interfaces parents.`),t(e,n[o])&&(f+=` removed, but interface still exist in parents prototypes constructors interfaces.`)):f=`not removed from own interfaces.`:(f=`not found in own interfaces.`,i.push(n[o])),r.warn&&f.length>0&&v._config.callbacks.warn({message:`Constructor ${s.name}. Interface ${n[o].name} was ${f}`})}l=c.length===n.length,f=!0}else r.warn&&v._config.callbacks.warn({message:`Constructor ${s.name} none interface was found. Interfaces ${b([],n).map(e=>e.name).join(", ")} was not removed from own interfaces.`});return r.debug&&O&&O.remove(l,e,n,f,c,i),l}function c(e,t){const n=e.constructor;let r=!1,o=!1;if(w.call(n,"__interfaces_")){const s=b([],n.__interfaces_.collection);0!==s.length&&(r=i(e,s,t)),o=!0}return t.debug&&O&&O.empty(r,e,null,o),r}function a(t,n){const r={values:t,options:{}};let o;return Array.isArray(t[0])&&(r.values=t[0],"object"==typeof t[1]&&(r.options=t[1],"object"==typeof r.options.descriptor&&(o=r.options.descriptor))),r.options="string"==typeof n?e(v._config,v._config[n],r.options):e(v._config,r.options),void 0!==o&&(r.options.descriptor=o),r}function l(e){if("function"==typeof e)return e.prototype;if("function"==typeof e.constructor&&e.constructor.prototype===e)return e;throw TypeError(`Wrong target, should be function (class) or prototype of function (class). Current value: ${e}.`)}function f(){const e=a(arguments);return{in:t=>s(l(t),e.values,e.options)}}function u(e){return b(Object.getOwnPropertyNames(e),x(e))}function p(e,t,n){const r=l(e),o=b([],t);let i=o.length;for(;i--;)w.call(r.constructor,"__interfaces_")&&r.constructor.__interfaces_.collection.indexOf(o[i])>-1&&o.splice(i,1);return s(r,o,n)}function d(e,t,n,r){const o=u(t),s=u(e),i={operation:"mixProperties",target:e,mixin:t,ignoredNames:[],notReplaced:[],replaced:[],defined:[],writed:[]};let c=o.length;for(;c--;){if(r.indexOf(o[c])>-1){n.debug&&i.ignoredNames.push(o[c]);continue}if("__interfaces_"===o[c]){n.interfaces&&(p(e,t.__interfaces_.collection,n),n.debug&&(i.interfaces=t.__interfaces_.collection));continue}const a=Object.getOwnPropertyDescriptor(t,o[c]);if(s.indexOf(o[c])>-1)if("__mixins_"===o[c])b(e.__mixins_,t.__mixins_),n.debug&&(i.mixins=t.__mixins_);else{const r="object"==typeof e;if(n.warn&&v._config.callbacks.warn({message:`Target ${r?`${e.constructor.name} prototype`:e.name} alredy have mixin (${r?`${t.constructor.name} prototype`:t.name}) property "${o[c]}". Will be ${n.replace?"replaced":"ignored"}.`}),n.replace){const s=Object.getOwnPropertyDescriptor(e,o[c]);if(s.configurable)Object.defineProperty(e,o[c],a),n.debug&&i.replaced.push(o[c]);else if(s.writable)e[o[c]]=t[o[c]],n.debug&&i.writed.push(o[c]);else if(n.notConfigurableNotWritableError){try{console.error("Trying to define not configurable and not writable value. Interf mixin debug info",i)}catch(e){}Object.defineProperty(e,o[c],a)}else n.debug&&i.notReplaced.push(o[c]),n.warn&&v._config.callbacks.warn({message:`Mixin ${r?`${t.constructor.name} prototype`:t.name} property "${o[c]}" ignored, because is not writable and not configurable`})}else n.debug&&i.notReplaced.push(o[c])}else Object.defineProperty(e,o[c],a),n.debug&&i.defined.push(o[c])}n.debug&&O&&O.mixProperties(!0,e,t,i)}function m(e){return function(){let t=h(this);for(;;){if(null===t)break;if(w.call(t.constructor,"__mixins_")){const n=t.constructor.__mixins_.length;let r=-1;for(;++r<n;){const n=new(Function.prototype.bind.apply(t.constructor.__mixins_[r],b([null],arguments))),o=Object.keys(n);let s=o.length;for(;s--;)(void 0===this[o[s]]||e)&&(this[o[s]]=n[o[s]])}}t=h(t)}}}function g(e,t,n){const r=[],o=t.length;let s=-1;for(;++s<o;){const o=l(t[s]);d(e,o,n,n.ignore.protoProps),d(e.constructor,o.constructor,n,n.ignore.staticProps),n.createInit&&r.push(o.constructor)}return n.createInit&&(void 0!==e.__interfaces_&&e.__interfaces_.has(C)||(Object.defineProperty(e,"initMixins",{configurable:!0,writable:!0,value:m(!!n.replace)}),"object"==typeof e.constructor.__interfaces_&&-1!==e.constructor.__interfaces_.collection.indexOf(C)||f(C).in(e)),w.call(e.constructor,"__mixins_")?b(e.constructor.__mixins_,r):Object.defineProperty(e.constructor,"__mixins_",{configurable:!0,writable:!0,value:r})),e.constructor}function _(e,t){const n={};let r=t.length;const o=new P(e);for(;r--;)"duplicates"===t[r]?n.duplicates=o.getDuplicates():"tree"===t[r]?n.tree=o.getTree():"list"===t[r]&&(n.list=o.getList());return n}const h=Object.getPrototypeOf||(e=>e.__proto__),b=(e,t)=>{const n=t.length;let r=-1;for(;++r<n;)e.push(t[r]);return e},y=(e,t)=>{const n=e,r=Object.keys(t);let o=r.length;for(;o--;)Array.isArray(t[r[o]])?Array.isArray(n[r[o]])?n[r[o]]=b(n[r[o]],t[r[o]]):n[r[o]]=b([],t[r[o]]):"object"==typeof t[r[o]]?"object"==typeof n[r[o]]?n[r[o]]=y(n[r[o]],t[r[o]]):n[r[o]]=y({},t[r[o]]):n[r[o]]=t[r[o]];return n},x=Object.getOwnPropertySymbols||(()=>[]),w=Object.prototype.hasOwnProperty,v={VERSION:1,_config:{warn:!1,debug:!1,afterImplement:!1,descriptor:{configurable:!0,writable:!1,enumerable:!1},callbacks:{warn:function(e){"object"==typeof console&&console.warn&&console.warn(e.message)},debug:function(e){"object"==typeof console&&console.log&&console.log(e.message,e)},afterImplement:function(e,t,n){}},mixin:{createInit:!0,interfaces:!0,replace:!0,notConfigurableNotWritableError:!0,ignore:{protoProps:["constructor","apply","bind","call","isGenerator","toSource","toString","__proto__"],staticProps:["arguments","arity","caller","length","name","displayName","prototype","__proto__"]}}}},I="ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""),j=class{constructor(e){if(void 0!==e.extends&&!Array.isArray(e.extends))throw TypeError("Interface extends should be an Array");if("string"!=typeof e.name||0===e.name.length)throw TypeError("Interface should have a name");{const t=Object.keys(e);let n=t.length;for(;n--;){if(!(I.indexOf(t[n][0])>-1||"name"===t[n]||"extends"===t[n]))throw Error("Interface optional property name should start with capital letter");this[t[n]]=e[t[n]]}}}isInterfaceOf(e){const n=h(e);if(null===n)return!1;const r=n.constructor.__interfaces_;return!(void 0===r||!r.has(this))||t(n,this)}};class ${constructor(e){this.collection=[],this.VERSION=e}add(e,t){const n=e.length;let r=-1;for(;++r<n;){let n=this.collection.length;for(;n--;)if(this.collection[n]===e[r])throw Error(`Class ${t} cannot implement previously implemented interface ${e[r].name}`);this.collection.push(e[r])}return this}remove(e){let t=this.collection.length;for(;t--;)if(e===this.collection[t])return this.collection.splice(t,1),!0;return!1}has(e){let t=this.collection.length;for(;t--;){if(e===this.collection[t])return!0;if("object"==typeof this.collection[t].extends&&this.extendsHas(e,this.collection[t].extends))return!0}return!1}extendsHas(e,t){let n=t.length;for(;n--;){if(e===t[n])return!0;if(void 0!==t[n].extends&&this.extendsHas(e,t[n].extends))return!0}return!1}}let O=!1;v.create=n,v.implement=f,v.remove=function(){const e=a(arguments);return{in:t=>i(l(t),e.values,e.options)}},v.empty=function(e){const t=a([[],e]).options;return{in:e=>c(l(e),t)}},v.configure=function(t){return this._config=e(this._config,t),"object"==typeof t.descriptor&&(this._config.descriptor=t.descriptor),this},v.utils={getProto:h,getSymbols:x,addArray:b,mergeObjects:y,assignObjects:e},v.internal={Interface:j,Interfaces:$,implementIn:s,removeIn:i,emptyIn:c,debugs:O,resolveArgs:a,targetProto:l};const C=n({name:"MixinsInitiable",Comments:["Class with this interface may init values provided by mixins"],Methods:["initMixins"],StaticProperties:["__mixins_: class[]"],Docs:"//shvabuk.github.io/interf"});class P{constructor(e){this.tree=[],this.initTree(e),this.list=[],this.initList()}initTree(e){let t=e;for(;;){if(null===t)break;if(w.call(t.constructor,"__interfaces_")){const e=t.constructor.__interfaces_.collection;this.tree.unshift({constructorName:t.constructor.name,proto:t,interfaces:e})}t=h(t)}return this.tree}initList(){const e=this.tree.length;let t=-1;for(;++t<e;)this.addInfo(this.tree[t].proto,this.tree[t].interfaces,this.tree[t].constructorName,!1);return this.list}addInfo(e,t,n,r){const o=t.length;let s=-1;for(;++s<o;){const o=t[s],i={constructorName:n,asExtendedInterface:r,proto:e};let c,a=this.list.length;for(;a--;)if(this.list[a].interface===o){c=this.list[a];break}void 0===c?this.list.push({interface:o,implementedIn:[i]}):c.implementedIn.push(i),void 0!==o.extends&&this.addInfo(e,o.extends,n,!0)}return this.list}getDuplicates(){const e=[],t=this.list.length;let n=-1;for(;++n<t;)this.list[n].implementedIn.length>1&&e.push(this.list[n]);return e}getList(){return this.list}getTree(){return this.tree}}return O={define:(e,t,n)=>{v._config.callbacks.debug({operation:"define",success:e,message:`Constructor ${t.constructor.name} prototype property __interfaces_ defined`,value:n,Constructor:t.constructor})},implement:(e,t,n)=>{const r=new P(t).getList();v._config.callbacks.debug({operation:"implement",success:e,message:`Constructor ${t.constructor.name} implemented own interfaces: ${t.constructor.__interfaces_.collection.map(e=>e.name).join(", ")}. All ${t.constructor.name} interfaces: ${r.map(e=>e.interface.name).join(", ")}`,value:n,allInterfaces:r,Constructor:t.constructor})},remove:(e,t,n,r,o,s)=>{if(r){const r=[],i=new P(t).getList(),c=i.length;let a=-1;for(;++a<c;){const e=n.length;let t=-1;for(;++t<e;)if(i[a].interface===n[t]){r.push(i[a]);break}}const l={operation:"remove",success:e,message:`Constructor ${t.constructor.name}.${(o.length>0?` Own interfaces: ${o.map(e=>e.name).join(", ")} was deleted.`:"")+(s.length>0?` Own interfaces: ${s.map(e=>e.name).join(", ")} was not found in ${t.constructor.name} interfaces collection.`:"")+(r.length>0?` Interfaces: ${r.map(e=>e.interface.name).join(", ")} still exist in parents constructor prototypes or parents interfaces.`:"")}`,value:n,Constructor:t.constructor,deleted:o,missed:s,stillExist:r,list:i};v._config.callbacks.debug(l)}else v._config.callbacks.debug({operation:"remove",success:e,message:`Constructor ${t.constructor.name} does not implement interf interfaces. Interface removing is not possible`,value:n,Constructor:t.constructor})},empty:(e,t,n,r)=>{r?v._config.callbacks.debug({operation:"empty",success:e,message:`Constructor ${t.constructor.name} empty ${e?"":"not "}all own interfaces`,value:n,Constructor:t.constructor}):v._config.callbacks.debug({operation:"empty",success:!1,message:`Constructor ${t.constructor.name} does not implement interf interfaces. Interface empty is not possible`,value:n,Constructor:t.constructor})},mixProperties:(e,t,n,r)=>{const o=r,s="function"!=typeof t;o.success=e,o.Constructor=s?t.constructor:t,o.message=`Constructor ${o.Constructor.name+(s?" prototype":"")} mixed with ${(s?n.constructor.name:n.name)+(s?" prototype":"")} properties.${o.notReplaced.length>0?` Not replaced properties: ${o.notReplaced.join(", ")}`:""}`,o.value=n,v._config.callbacks.debug(o)}},v.mix=function(){const e=a(arguments,"mixin");return{in:t=>g(l(t),e.values,e.options)}},v.debug=function(e){const t=["duplicates","tree","list"];let n;if(void 0===e)n=t;else if("string"==typeof e)n="all"===e?t:[e];else{if(!Array.isArray(e))throw TypeError(`debug first argument should be undefined, array, or string (${t.join(", ")}, all)`);n=e}return{in:e=>_(l(e),n)}},v.interfaces={MixinsInitiable:C},v.internal.DebugInterfaces=P,v.internal.mixIn=g,v.internal.debugIn=_,v.internal.debugs=O,v});
//# sourceMappingURL=interf-es.min.js.map
