{"version":3,"sources":["interf.js"],"names":["root","factory","define","amd","module","exports","interf","nodeName","Number","isInteger","VERSION","this","assignObjects","len","arguments","length","i","ret","mergeObjects","parentHas","target","Interface","prototype","getProto","interfaces","constructor","__interfaces_","has","defineInterfacesProp","proto","parent","options","value","Interfaces","version","descriptor","_config","set","Object","defineProperty","debug","debugs","validateInterfaces","TypeError","isInterfaceOf","name","implementIn","hasProp","call","add","afterImplement","callbacks","implement","removeIn","missed","deleted","collection","success","interfaced","warnMsg","indexOf","remove","push","warn","message","addArray","map","join","emptyIn","empty","resolveArgs","args","section","values","Array","isArray","targetProto","getPrototypeOf","obj","__proto__","source","destination","keys","getSymbols","getOwnPropertySymbols","hasOwnProperty","configurable","writable","enumerable","data","console","log","classInterfaces","Class","mixin","createInit","replace","notConfigurableNotWritableError","ignore","protoProps","staticProps","CAPITAL_CHARS","split","InterfaceClass","properties","extends","Error","object","constructorName","j","this$1","splice","extendsHas","create","interfaceName","extendsArray","ar","in","opts","configure","utils","internal"],"mappings":"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","file":"interf-core.min.js","sourcesContent":["/**\n * @license\n * Interf <https://shvabuk.github.io/interf>\n * Released under MIT license <https://shvabuk.github.io/interf/LICENSE.txt>\n * Copyright Shvab Ostap\n */\n;((root, factory) => {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node.\n    const interf = factory();\n    module.exports = interf;\n    // CommonJS exports\n    module.exports.interf = interf;\n  } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n    // CommonJS\n    exports.interf = factory();\n  } else if (typeof root.interf !== 'object' || !Number.isInteger(root.interf.VERSION)) {\n    root.interf = factory();\n  }\n})(this, () => {\n  'use strict';\n  // ------------------------------------------------------------------------\n  // utils block start\n\n  // get object prototype\n  const getProto = Object.getPrototypeOf || (obj => obj.__proto__);\n  // add source array values to target array, source array values may be arguments object (is array like)\n  const addArray = (target, source) => {\n    const len = source.length;\n    let i = -1;\n    while (++i < len) {\n      target.push(source[i]);\n    }\n    return target;\n  };\n  // merge source object values in target object recursively, arrays merged by addArray\n  const mergeObjects = (target, source) => {\n    const destination = target;\n    const keys = Object.keys(source);\n    let i = keys.length;\n    while (i--) {\n      if (Array.isArray(source[keys[i]])) {\n        if (Array.isArray(destination[keys[i]])) {\n          // append array\n          destination[keys[i]] = addArray(destination[keys[i]], source[keys[i]]);\n        } else {\n          // create new array\n          destination[keys[i]] = addArray([], source[keys[i]]);\n        }\n      } else if (typeof source[keys[i]] === 'object') {\n        if (typeof destination[keys[i]] === 'object') {\n          // mutate destination[key]\n          destination[keys[i]] = mergeObjects(destination[keys[i]], source[keys[i]]);\n        } else {\n          // merge source[key] to new object\n          destination[keys[i]] = mergeObjects({}, source[keys[i]]);\n        }\n      } else {\n        destination[keys[i]] = source[keys[i]];\n      }\n    }\n\n    return destination;\n  };\n  // merge objects values in new obj, arrays merged\n  function assignObjects() {\n    const len = arguments.length;\n    let i = -1;\n    let ret = {};\n    while (++i < len) {\n      ret = mergeObjects(ret, arguments[i]);\n    }\n    return ret;\n  }\n\n  // get symbols, if method not provided, will return empty array, needed for getOwnPropsKeys\n  const getSymbols = Object.getOwnPropertySymbols || (() => []);\n\n  // utils block end\n  // ------------------------------------------------------------------------\n\n  // has own property check, usage: has.call(obj, 'propName');\n  const hasProp = Object.prototype.hasOwnProperty;\n\n  // main object\n  const interf = {\n    // integer count of all versions, current version: 1.0.0\n    VERSION: 1,\n    _config: {\n      // use interf.configure to set config values\n      warn: false,\n      debug: false, // ignored in core build\n      afterImplement: false,\n      descriptor: {\n        // value: (auto-defined, in case when setter is defined will be auto-assigned),\n        configurable: true,\n        writable: false,\n        enumerable: false,\n        // set: undefined,\n        // get: undefined,\n      },\n      callbacks: {\n        warn: function warnCallback(data) {\n          if (typeof console === 'object' && console.warn) console.warn(data.message);\n        },\n        // ignored in core build\n        debug: function debugCallback(data) {\n          if (typeof console === 'object' && console.log) console.log(data.message, data);\n        },\n        afterImplement: function afterImplementCallback(classInterfaces, Class, interfaces) {},\n      },\n      // ignored in core build\n      mixin: {\n        // warn: this.,\n        // debug: false,\n        createInit: true, // create initMixins method in target prototype\n        interfaces: true,\n        replace: true,\n        notConfigurableNotWritableError: true, // ignored if replace == false,\n        // https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\n        ignore: {\n          protoProps: [\n            'constructor',\n            'apply',\n            'bind',\n            'call',\n            'isGenerator',\n            'toSource',\n            'toString',\n            '__proto__',\n          ],\n          staticProps: [\n            'arguments',\n            'arity',\n            'caller',\n            'length',\n            'name',\n            'displayName',\n            'prototype',\n            '__proto__',\n          ],\n        },\n      },\n    },\n  };\n\n  const CAPITAL_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n  function parentHas(target, Interface) {\n    const prototype = getProto(target);\n    if (prototype === null) return false;\n    const interfaces = prototype.constructor.__interfaces_;\n    if (typeof interfaces !== 'undefined' && interfaces.has(Interface)) return true;\n    return parentHas(prototype, Interface);\n  }\n\n  // Base interface class\n  const InterfaceClass = class Interface {\n    constructor(properties) {\n      if (typeof properties.extends !== 'undefined' && !Array.isArray(properties.extends)) {\n        throw TypeError('Interface extends should be an Array');\n      }\n      if (typeof properties.name === 'string' && properties.name.length !== 0) {\n        const keys = Object.keys(properties);\n        let i = keys.length;\n        // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n        while (i--) {\n          if (\n            CAPITAL_CHARS.indexOf(keys[i][0]) > -1 ||\n            keys[i] === 'name' ||\n            keys[i] === 'extends'\n          ) {\n            this[keys[i]] = properties[keys[i]];\n          } else {\n            throw Error('Interface optional property name should start with capital letter');\n          }\n        }\n      } else {\n        throw TypeError('Interface should have a name');\n      }\n    }\n\n    isInterfaceOf(object) {\n      // code repeating here, same as in parentHas()\n      // those solulution works faster than just using of parentHas()\n      // TODO: check in others environments\n      const prototype = getProto(object);\n      if (prototype === null) return false;\n      const interfaces = prototype.constructor.__interfaces_;\n      if (typeof interfaces !== 'undefined' && interfaces.has(this)) return true;\n      return parentHas(prototype, this);\n    }\n  };\n\n  // interf.create(), create Interface\n  function create(interfaceName, extendsArray) {\n    // no need in rest args (...args), also minimize code (babel will transform it\n    // to arguments anyway)\n    const ar = arguments;\n    if (typeof ar[0] === 'string') {\n      const obj = { name: ar[0] };\n      if (typeof ar[1] !== 'undefined') obj.extends = ar[1];\n      return new InterfaceClass(obj);\n    } else if (typeof ar[0] === 'object') {\n      return new InterfaceClass(ar[0]);\n    }\n    throw TypeError(\n      'In method interf.create first parameter should be an object or Interface name'\n    );\n  }\n\n  // Interfaces objects are stored in __interfaces_\n  class Interfaces {\n    constructor(version) {\n      this.collection = [];\n      this.VERSION = version;\n    }\n\n    // add only unique, but not unique in extends or parent\n    // mainly incoming parameter will be arguments object (array like)\n    add(interfaces, constructorName) {\n      const len = interfaces.length;\n      let i = -1;\n      while (++i < len) {\n        let j = this.collection.length;\n        // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n        while (j--) {\n          if (this.collection[j] === interfaces[i]) {\n            throw Error(\n              `Class ${constructorName} cannot implement previously implemented interface ${interfaces[\n                i\n              ].name}`\n            );\n          }\n        }\n\n        this.collection.push(interfaces[i]);\n      }\n      return this;\n    }\n\n    remove(Interface) {\n      let i = this.collection.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        if (Interface === this.collection[i]) {\n          this.collection.splice(i, 1);\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // check instance interfaces\n    // comparison is fastest solution\n    has(Interface) {\n      let i = this.collection.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        if (Interface === this.collection[i]) return true;\n        // check extended interfaces\n        if (\n          typeof this.collection[i].extends === 'object' &&\n          this.extendsHas(Interface, this.collection[i].extends)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    extendsHas(Interface, collection) {\n      let i = collection.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        if (Interface === collection[i]) return true;\n        // check extended interfaces\n        if (\n          typeof collection[i].extends !== 'undefined' &&\n          this.extendsHas(Interface, collection[i].extends)\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function configure(properties) {\n    this._config = assignObjects(this._config, properties);\n\n    // descriptor should be rewrited\n    if (typeof properties.descriptor === 'object') {\n      this._config.descriptor = properties.descriptor;\n    }\n\n    return this;\n  }\n\n  // debug information computing functions\n  let debugs = false;\n\n  // define __interfaces_ in prototype\n  function defineInterfacesProp(proto, parent, options) {\n    const value = new Interfaces(interf.version, parent);\n    const descriptor = assignObjects(options.descriptor); // assign to empty object {}\n\n    if (typeof interf._config.descriptor.set !== 'function') {\n      descriptor.value = value;\n    }\n\n    Object.defineProperty(proto.constructor, '__interfaces_', descriptor);\n    if (typeof descriptor.set === 'function') {\n      proto.constructor.__interfaces_ = value;\n    }\n\n    if (options.debug && debugs) debugs.define(true, proto, value);\n  }\n\n  function validateInterfaces(interfaces) {\n    let i = interfaces.length;\n    while (i--) {\n      if (typeof interfaces[i] !== 'object') {\n        throw TypeError(`Undefined type ${typeof interfaces[i]} of interface`);\n      } else if (typeof interfaces[i].isInterfaceOf !== 'function') {\n        throw TypeError(`Undefined type of interface: ${interfaces[i].name}`);\n      }\n    }\n  }\n\n  // implement interface function\n  function implementIn(prototype, interfaces, options) {\n    validateInterfaces(interfaces);\n\n    const constructor = prototype.constructor;\n\n    if (!hasProp.call(constructor, '__interfaces_')) {\n      defineInterfacesProp(prototype, null, options);\n    }\n\n    // add intefaces to prototype\n    constructor.__interfaces_.add(interfaces, constructor.name);\n\n    if (interf._config.afterImplement) {\n      interf._config.callbacks.afterImplement(constructor.__interfaces_, constructor, interfaces);\n    }\n\n    if (options.debug && debugs) debugs.implement(true, prototype, interfaces);\n\n    return constructor;\n  }\n\n  // remove function\n  function removeIn(prototype, interfaces, options) {\n    validateInterfaces(interfaces);\n\n    const constructor = prototype.constructor;\n    const missed = [];\n    const deleted = [];\n    let collection;\n    let success = false;\n    let interfaced = false;\n    if (hasProp.call(constructor, '__interfaces_')) {\n      collection = constructor.__interfaces_.collection;\n\n      let i = interfaces.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        const index = collection.indexOf(interfaces[i]);\n        let warnMsg = '';\n\n        if (index > -1) {\n          if (constructor.__interfaces_.remove(interfaces[i])) {\n            deleted.push(interfaces[i]);\n\n            if (constructor.__interfaces_.has(interfaces[i])) {\n              warnMsg = `removed, but interface still exist in other interfaces parents.`;\n            }\n\n            if (parentHas(prototype, interfaces[i])) {\n              warnMsg += ` removed, but interface still exist in parents prototypes constructors interfaces.`;\n            }\n          } else {\n            warnMsg = `not removed from own interfaces.`;\n          }\n        } else {\n          warnMsg = `not found in own interfaces.`;\n\n          missed.push(interfaces[i]);\n        }\n\n        if (options.warn && warnMsg.length > 0) {\n          interf._config.callbacks.warn({\n            message: `Constructor ${constructor.name}. Interface ${interfaces[i]\n              .name} was ${warnMsg}`,\n          });\n        }\n      }\n\n      success = deleted.length === interfaces.length;\n\n      interfaced = true;\n    } else if (options.warn) {\n      interf._config.callbacks.warn({\n        message: `Constructor ${constructor.name} none interface was found. Interfaces ${addArray(\n          [],\n          interfaces\n        )\n          .map(Interface => Interface.name)\n          .join(', ')} was not removed from own interfaces.`,\n      });\n    }\n\n    if (options.debug && debugs) {\n      debugs.remove(success, prototype, interfaces, interfaced, deleted, missed);\n    }\n\n    return success;\n  }\n\n  // empty function\n  function emptyIn(prototype, options) {\n    const constructor = prototype.constructor;\n    let success = false;\n    let interfaced = false;\n    if (hasProp.call(constructor, '__interfaces_')) {\n      // create new array\n      const interfaces = addArray([], constructor.__interfaces_.collection);\n      if (interfaces.length !== 0) {\n        success = removeIn(prototype, interfaces, options);\n      }\n\n      interfaced = true;\n    }\n\n    if (options.debug && debugs) debugs.empty(success, prototype, null, interfaced);\n\n    return success;\n  }\n\n  // resolve input arguments\n  function resolveArgs(args, section) {\n    const ret = { values: args, options: {} };\n    let descriptor;\n    if (Array.isArray(args[0])) {\n      ret.values = args[0];\n      if (typeof args[1] === 'object') {\n        ret.options = args[1];\n        if (typeof ret.options.descriptor === 'object') {\n          descriptor = ret.options.descriptor;\n        }\n      }\n    }\n\n    if (typeof section === 'string') {\n      ret.options = assignObjects(interf._config, interf._config[section], ret.options);\n    } else {\n      ret.options = assignObjects(interf._config, ret.options);\n    }\n\n    // special rule for descriptor option\n    // descriptor should be rewrited\n    if (typeof descriptor !== 'undefined') {\n      ret.options.descriptor = descriptor;\n    }\n\n    return ret;\n  }\n\n  // get proto of given in \".in(target)\" method argument\n  function targetProto(target) {\n    if (typeof target === 'function') {\n      return target.prototype;\n    } else if (\n      // check is protolike object\n      typeof target.constructor === 'function' &&\n      target.constructor.prototype === target\n    ) {\n      return target;\n    }\n    throw TypeError(\n      `Wrong target, should be function (class) or prototype of function (class). Current value: ${target}.`\n    );\n  }\n\n  // interf.implement()\n  function implement() {\n    // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n    const args = resolveArgs(arguments);\n    return {\n      in: target => implementIn(targetProto(target), args.values, args.options),\n    };\n  }\n\n  // interf.remove()\n  function remove() {\n    // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n    const args = resolveArgs(arguments);\n    return {\n      in: target => removeIn(targetProto(target), args.values, args.options),\n    };\n  }\n\n  // interf.empty()\n  function empty(options) {\n    const opts = resolveArgs([[], options]).options;\n    return {\n      in: target => emptyIn(targetProto(target), opts),\n    };\n  }\n\n  // core\n  interf.create = create;\n  interf.implement = implement;\n  interf.remove = remove;\n  interf.empty = empty;\n  interf.configure = configure;\n  // core additional\n  interf.utils = {\n    getProto,\n    getSymbols,\n    addArray,\n    mergeObjects,\n    assignObjects,\n  };\n  interf.internal = {\n    Interface: InterfaceClass,\n    Interfaces,\n    implementIn,\n    removeIn,\n    emptyIn,\n    debugs,\n    resolveArgs,\n    targetProto,\n  };\n\n  // @NOT_CORE_BEGIN@\n\n  // Interface for objects mixined with classes with constructor method, and mark that initMixins method are able\n  const MixinsInitiable = create({\n    name: 'MixinsInitiable',\n    Comments: ['Class with this interface may init values provided by mixins'],\n    Methods: ['initMixins'],\n    StaticProperties: ['__mixins_: class[]'],\n    Docs: '//shvabuk.github.io/interf',\n  });\n\n  // class for getting debug information\n  class DebugInterfaces {\n    constructor(prototype) {\n      this.tree = [];\n      this.initTree(prototype);\n      this.list = [];\n      this.initList();\n    }\n\n    // use proto chain here because we need proto info, that may not provided by parent property\n    initTree(prototype) {\n      let proto = prototype;\n      while (true) {\n        if (proto === null) {\n          break;\n        }\n\n        if (hasProp.call(proto.constructor, '__interfaces_')) {\n          const interfs = proto.constructor.__interfaces_.collection;\n          this.tree.unshift({\n            constructorName: proto.constructor.name,\n            proto,\n            interfaces: interfs,\n          });\n        }\n\n        proto = getProto(proto);\n      }\n      return this.tree;\n    }\n\n    initList() {\n      const len = this.tree.length;\n      let i = -1;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (++i < len) {\n        this.addInfo(\n          this.tree[i].proto,\n          this.tree[i].interfaces,\n          this.tree[i].constructorName,\n          false\n        );\n      }\n      return this.list;\n    }\n\n    addInfo(proto, collection, constructorName, extended) {\n      const len = collection.length;\n      let i = -1;\n      while (++i < len) {\n        const InterFace = collection[i];\n        const info = { constructorName, asExtendedInterface: extended, proto };\n        let result;\n        let j = this.list.length;\n        // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n        while (j--) {\n          if (this.list[j].interface === InterFace) {\n            result = this.list[j];\n            break;\n          }\n        }\n        if (typeof result === 'undefined') {\n          this.list.push({ interface: InterFace, implementedIn: [info] });\n        } else {\n          result.implementedIn.push(info);\n        }\n\n        if (typeof InterFace.extends !== 'undefined') {\n          this.addInfo(proto, InterFace.extends, constructorName, true);\n        }\n      }\n      return this.list;\n    }\n\n    getDuplicates() {\n      const results = [];\n\n      const len = this.list.length;\n      let i = -1;\n      while (++i < len) {\n        if (this.list[i].implementedIn.length > 1) results.push(this.list[i]);\n      }\n\n      return results;\n    }\n\n    getList() {\n      return this.list;\n    }\n\n    getTree() {\n      return this.tree;\n    }\n  }\n\n  debugs = {\n    define: (success, proto, value) => {\n      interf._config.callbacks.debug({\n        operation: 'define',\n        success,\n        message: `Constructor ${proto.constructor.name} prototype property __interfaces_ defined`,\n        value,\n        Constructor: proto.constructor,\n      });\n    },\n    implement: (success, proto, value) => {\n      const allInterfaces = new DebugInterfaces(proto).getList();\n      interf._config.callbacks.debug({\n        operation: 'implement',\n        success,\n        message: `Constructor ${proto.constructor\n          .name} implemented own interfaces: ${proto.constructor.__interfaces_.collection\n          .map(InterFace => InterFace.name)\n          .join(', ')}. All ${proto.constructor.name} interfaces: ${allInterfaces\n          .map(data => data.interface.name)\n          .join(', ')}`,\n        value,\n        allInterfaces,\n        Constructor: proto.constructor,\n      });\n    },\n    remove: (success, proto, interfs, interfaced, deleted, missed) => {\n      if (interfaced) {\n        const stillExist = [];\n        const interfacesList = new DebugInterfaces(proto).getList();\n        const listLen = interfacesList.length;\n        let i = -1;\n        while (++i < listLen) {\n          const len = interfs.length;\n          let j = -1;\n          while (++j < len) {\n            if (interfacesList[i].interface === interfs[j]) {\n              stillExist.push(interfacesList[i]);\n              break;\n            }\n          }\n        }\n\n        const data = {\n          operation: 'remove',\n          success,\n          message: `Constructor ${proto.constructor.name}.${(deleted.length > 0\n            ? ` Own interfaces: ${deleted.map(InterFace => InterFace.name).join(', ')} was deleted.`\n            : '') +\n            (missed.length > 0\n              ? ` Own interfaces: ${missed\n                  .map(InterFace => InterFace.name)\n                  .join(', ')} was not found in ${proto.constructor.name} interfaces collection.`\n              : '') +\n            (stillExist.length > 0\n              ? ` Interfaces: ${stillExist\n                  .map(listednterface => listednterface.interface.name)\n                  .join(', ')} still exist in parents constructor prototypes or parents interfaces.`\n              : '')}`,\n          value: interfs,\n          Constructor: proto.constructor,\n          deleted,\n          missed,\n          stillExist,\n          list: interfacesList,\n        };\n\n        interf._config.callbacks.debug(data);\n      } else {\n        interf._config.callbacks.debug({\n          operation: 'remove',\n          success,\n          message: `Constructor ${proto.constructor\n            .name} does not implement interf interfaces. Interface removing is not possible`,\n          value: interfs,\n          Constructor: proto.constructor,\n        });\n      }\n    },\n    empty: (success, proto, value, interfaced) => {\n      if (interfaced) {\n        interf._config.callbacks.debug({\n          operation: 'empty',\n          success,\n          message: `Constructor ${proto.constructor.name} empty ${success\n            ? ''\n            : 'not '}all own interfaces`,\n          value,\n          Constructor: proto.constructor,\n        });\n      } else {\n        interf._config.callbacks.debug({\n          operation: 'empty',\n          success: false,\n          message: `Constructor ${proto.constructor\n            .name} does not implement interf interfaces. Interface empty is not possible`,\n          value,\n          Constructor: proto.constructor,\n        });\n      }\n    },\n    mixProperties: (success, target, mixin, debugData) => {\n      const data = debugData;\n      const isPrototype = typeof target !== 'function';\n      data.success = success;\n      data.Constructor = isPrototype ? target.constructor : target;\n      data.message = `Constructor ${data.Constructor.name +\n        (isPrototype ? ' prototype' : '')} mixed with ${(isPrototype\n        ? mixin.constructor.name\n        : mixin.name) + (isPrototype ? ' prototype' : '')} properties.${data.notReplaced.length > 0\n        ? ` Not replaced properties: ${data.notReplaced.join(', ')}`\n        : ''}`;\n\n      data.value = mixin;\n      interf._config.callbacks.debug(data);\n    },\n  };\n\n  // get props names, used in mixin\n  function getOwnPropsKeys(target) {\n    return addArray(Object.getOwnPropertyNames(target), getSymbols(target));\n  }\n\n  function implementByMixIn(target, interfaces, options) {\n    const prototype = targetProto(target);\n    // create new array, transform arguments to array\n    const interfs = addArray([], interfaces);\n\n    let i = interfs.length;\n    // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n    while (i--) {\n      // ignore duplicates\n      if (\n        hasProp.call(prototype.constructor, '__interfaces_') &&\n        prototype.constructor.__interfaces_.collection.indexOf(interfs[i]) > -1\n      ) {\n        interfs.splice(i, 1);\n      }\n    }\n\n    return implementIn(prototype, interfs, options);\n  }\n\n  // define mixin (constructor or prototype) properties\n  function defineProps(target, mixin, options, ignore) {\n    const mixinNames = getOwnPropsKeys(mixin);\n    const targetNames = getOwnPropsKeys(target);\n    const debugData = {\n      operation: 'mixProperties',\n      target,\n      mixin,\n      ignoredNames: [],\n      notReplaced: [],\n      replaced: [],\n      defined: [],\n      writed: [],\n    };\n\n    let i = mixinNames.length;\n    // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n    while (i--) {\n      // ignore props from ignorelist\n      if (ignore.indexOf(mixinNames[i]) > -1) {\n        if (options.debug) debugData.ignoredNames.push(mixinNames[i]);\n        continue;\n      }\n      // implement interfaces\n      if (mixinNames[i] === '__interfaces_') {\n        if (options.interfaces) {\n          implementByMixIn(target, mixin.__interfaces_.collection, options);\n          if (options.debug) debugData.interfaces = mixin.__interfaces_.collection;\n        }\n        continue;\n      }\n\n      const descriptor = Object.getOwnPropertyDescriptor(mixin, mixinNames[i]);\n      // check prop name in target\n      if (targetNames.indexOf(mixinNames[i]) > -1) {\n        // add mixins constructors if exists\n        if (mixinNames[i] === '__mixins_') {\n          addArray(target.__mixins_, mixin.__mixins_);\n          if (options.debug) debugData.mixins = mixin.__mixins_;\n        } else {\n          const isProto = typeof target === 'object';\n\n          if (options.warn) {\n            interf._config.callbacks.warn({\n              message: `Target ${isProto\n                ? `${target.constructor.name} prototype`\n                : target.name} alredy have mixin (${isProto\n                ? `${mixin.constructor.name} prototype`\n                : mixin.name}) property \"${mixinNames[i]}\". Will be ${options.replace\n                ? 'replaced'\n                : 'ignored'}.`,\n            });\n          }\n\n          if (options.replace) {\n            // resolve conflicts\n            const targetDescriptor = Object.getOwnPropertyDescriptor(target, mixinNames[i]);\n            if (!targetDescriptor.configurable) {\n              if (targetDescriptor.writable) {\n                // write property\n                target[mixinNames[i]] = mixin[mixinNames[i]];\n                if (options.debug) debugData.writed.push(mixinNames[i]);\n              } else if (options.notConfigurableNotWritableError) {\n                try {\n                  // show some additional info\n                  console.error(\n                    'Trying to define not configurable and not writable value. Interf mixin debug info',\n                    debugData\n                  );\n                } catch (e) {}\n                // force error throwing\n                Object.defineProperty(target, mixinNames[i], descriptor);\n              } else {\n                // ignore if options.notConfigurableNotWritableError = false and targetDescriptor.configurable true\n                if (options.debug) debugData.notReplaced.push(mixinNames[i]);\n                if (options.warn) {\n                  interf._config.callbacks.warn({\n                    message: `Mixin ${isProto\n                      ? `${mixin.constructor.name} prototype`\n                      : mixin.name} property \"${mixinNames[\n                      i\n                    ]}\" ignored, because is not writable and not configurable`,\n                  });\n                }\n              }\n            } else {\n              // replace value\n              Object.defineProperty(target, mixinNames[i], descriptor);\n              if (options.debug) debugData.replaced.push(mixinNames[i]);\n            }\n          } else if (options.debug) {\n            // ignore if options.replace == false\n            debugData.notReplaced.push(mixinNames[i]);\n          }\n        }\n      } else {\n        // define property\n        Object.defineProperty(target, mixinNames[i], descriptor);\n        if (options.debug) debugData.defined.push(mixinNames[i]);\n      }\n    }\n\n    if (options.debug && debugs) debugs.mixProperties(true, target, mixin, debugData);\n  }\n\n  // return initMixins function, MixinsInitiable objects method\n  // may be used if interf._config.mixin.createInit or options.createInit is true\n  function createInitMixins(replace) {\n    return function initMixins() {\n      // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n      let prototype = getProto(this);\n      while (true) {\n        if (prototype === null) {\n          break;\n        }\n\n        if (hasProp.call(prototype.constructor, '__mixins_')) {\n          const length = prototype.constructor.__mixins_.length;\n          let j = -1;\n          while (++j < length) {\n            // const mixinObject = new prototype.constructor.__mixins_[j](...args);\n            // compiled by babel\n            const mixinObject = new (Function.prototype.bind.apply(\n              prototype.constructor.__mixins_[j],\n              addArray([null], arguments)\n            ))();\n            const keys = Object.keys(mixinObject);\n            let i = keys.length;\n            // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n            while (i--) {\n              if (typeof this[keys[i]] === 'undefined' || replace) {\n                this[keys[i]] = mixinObject[keys[i]];\n              }\n            }\n          }\n        }\n\n        prototype = getProto(prototype);\n      }\n    };\n  }\n\n  // mixin function\n  function mixIn(targetPrototype, mixins, options) {\n    const mixinsConstructors = [];\n    const len = mixins.length;\n    let i = -1;\n    while (++i < len) {\n      const mixinProto = targetProto(mixins[i]);\n      defineProps(targetPrototype, mixinProto, options, options.ignore.protoProps);\n      defineProps(\n        targetPrototype.constructor,\n        mixinProto.constructor,\n        options,\n        options.ignore.staticProps\n      );\n      if (options.createInit) mixinsConstructors.push(mixinProto.constructor);\n    }\n\n    if (options.createInit) {\n      if (\n        typeof targetPrototype.__interfaces_ === 'undefined' ||\n        !targetPrototype.__interfaces_.has(MixinsInitiable)\n      ) {\n        Object.defineProperty(targetPrototype, 'initMixins', {\n          configurable: true,\n          writable: true,\n          value: createInitMixins(!!options.replace), // always convert replace to primitive\n        });\n\n        if (\n          typeof targetPrototype.constructor.__interfaces_ !== 'object' ||\n          targetPrototype.constructor.__interfaces_.collection.indexOf(MixinsInitiable) === -1\n        ) {\n          implement(MixinsInitiable).in(targetPrototype);\n        }\n      }\n\n      if (hasProp.call(targetPrototype.constructor, '__mixins_')) {\n        addArray(targetPrototype.constructor.__mixins_, mixinsConstructors);\n      } else {\n        Object.defineProperty(targetPrototype.constructor, '__mixins_', {\n          configurable: true,\n          writable: true,\n          value: mixinsConstructors,\n        });\n      }\n    }\n\n    return targetPrototype.constructor;\n  }\n\n  // debug function\n  function debugIn(prototype, actions) {\n    const information = {};\n    let i = actions.length;\n    const debugInfo = new DebugInterfaces(prototype);\n\n    // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n    while (i--) {\n      if (actions[i] === 'duplicates') {\n        information.duplicates = debugInfo.getDuplicates();\n      } else if (actions[i] === 'tree') {\n        information.tree = debugInfo.getTree();\n      } else if (actions[i] === 'list') {\n        information.list = debugInfo.getList();\n      }\n    }\n\n    return information;\n  }\n\n  // interf.debug() resolve given arguments and run debug\n  function debug(action) {\n    const allActions = ['duplicates', 'tree', 'list'];\n    let values;\n    if (typeof action === 'undefined') {\n      values = allActions;\n    } else if (typeof action === 'string') {\n      if (action === 'all') {\n        values = allActions;\n      } else {\n        values = [action];\n      }\n    } else if (Array.isArray(action)) {\n      values = action;\n    } else {\n      throw TypeError(\n        `debug first argument should be undefined, array, or string (${allActions.join(', ')}, all)`\n      );\n    }\n\n    return {\n      in: target => debugIn(targetProto(target), values),\n    };\n  }\n\n  // interf.mix()\n  function mix() {\n    // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n    const args = resolveArgs(arguments, 'mixin');\n\n    return {\n      in: target => mixIn(targetProto(target), args.values, args.options),\n    };\n  }\n\n  // full\n  interf.mix = mix;\n  interf.debug = debug;\n  // additional\n  interf.interfaces = { MixinsInitiable };\n  interf.internal.DebugInterfaces = DebugInterfaces;\n  interf.internal.mixIn = mixIn;\n  interf.internal.debugIn = debugIn;\n  interf.internal.debugs = debugs;\n\n  // @NOT_CORE_END@\n\n  return interf;\n});\n"]}