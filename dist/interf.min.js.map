{"version":3,"sources":["interf.js"],"names":["root","factory","define","amd","module","exports","interf","nodeName","Number","isInteger","VERSION","this","destination","len","arguments","length","i","ret","mergeObjects","parentHas","target","Interface","prototype","getProto","properties","extends","interfaces","TypeError","constructor","__interfaces_","has","extendsArray","ar","Interfaces","collection","name","version","obj","InterfaceClass","add","proto","parent","options","value","descriptor","isInterfaceOf","_config","Object","defineProperty","set","debug","debugs","hasProp","defineInterfacesProp","implementIn","validateInterfaces","removeIn","deleted","success","afterImplement","interfaced","callbacks","implement","missed","warnMsg","indexOf","remove","push","message","warn","addArray","join","empty","values","Array","isArray","args","call","resolveArgs","section","assignObjects","targetProto","in","getOwnPropsKeys","getOwnPropertyNames","getSymbols","interfs","debugData","mixinNames","splice","targetNames","defineProps","ignore","mixin","operation","ignoredNames","notReplaced","replaced","defined","writed","targetDescriptor","notConfigurableNotWritableError","getOwnPropertyDescriptor","__mixins_","isProto","replace","createInitMixins","writable","error","j","mixinObject","keys","mixinProto","mixins","implementByMixIn","mixProperties","configurable","targetPrototype","Function","bind","apply","mixinsConstructors","mixIn","actions","information","protoProps","action","allActions","staticProps","MixinsInitiable","debugIn","mix","internal","DebugInterfaces","duplicates","debugInfo","getDuplicates","tree","getTree","list","getList","getPrototypeOf","__proto__","source","getOwnPropertySymbols","hasOwnProperty","data","console","log","warnCallback","classInterfaces","Class","createInit","CAPITAL_CHARS","split","object","constructorName","this$1","extendsHas","configure","create","utils","opts","Comments","Methods","Docs","emptyIn","StaticProperties","unshift","initList","initTree","info","result","addInfo","extended","InterFace","asExtendedInterface","interface","results","implementedIn","allInterfaces","Constructor","interfacesList","listLen","map","stillExist","listednterface","isPrototype"],"mappings":"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","file":"interf.min.js","sourcesContent":["/**\n * @license\n * Interf <https://shvabuk.github.io/interf>\n * Released under MIT license <https://shvabuk.github.io/interf/LICENSE.txt>\n * Copyright Shvab Ostap\n */\n;((root, factory) => {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node.\n    const interf = factory();\n    module.exports = interf;\n    // CommonJS exports\n    module.exports.interf = interf;\n  } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n    // CommonJS\n    exports.interf = factory();\n  } else if (typeof root.interf !== 'object' || !Number.isInteger(root.interf.VERSION)) {\n    root.interf = factory();\n  }\n})(this, () => {\n  'use strict';\n  // ------------------------------------------------------------------------\n  // utils block start\n\n  // get object prototype\n  const getProto = Object.getPrototypeOf || (obj => obj.__proto__);\n  // add source array values to target array, source array values may be arguments object (is array like)\n  const addArray = (target, source) => {\n    const len = source.length;\n    let i = -1;\n    while (++i < len) {\n      target.push(source[i]);\n    }\n    return target;\n  };\n  // merge source object values in target object recursively, arrays merged by addArray\n  const mergeObjects = (target, source) => {\n    const destination = target;\n    const keys = Object.keys(source);\n    let i = keys.length;\n    while (i--) {\n      if (Array.isArray(source[keys[i]])) {\n        if (Array.isArray(destination[keys[i]])) {\n          // append array\n          destination[keys[i]] = addArray(destination[keys[i]], source[keys[i]]);\n        } else {\n          // create new array\n          destination[keys[i]] = addArray([], source[keys[i]]);\n        }\n      } else if (typeof source[keys[i]] === 'object') {\n        if (typeof destination[keys[i]] === 'object') {\n          // mutate destination[key]\n          destination[keys[i]] = mergeObjects(destination[keys[i]], source[keys[i]]);\n        } else {\n          // merge source[key] to new object\n          destination[keys[i]] = mergeObjects({}, source[keys[i]]);\n        }\n      } else {\n        destination[keys[i]] = source[keys[i]];\n      }\n    }\n\n    return destination;\n  };\n  // merge objects values in new obj, arrays merged\n  function assignObjects() {\n    const len = arguments.length;\n    let i = -1;\n    let ret = {};\n    while (++i < len) {\n      ret = mergeObjects(ret, arguments[i]);\n    }\n    return ret;\n  }\n\n  // get symbols, if method not provided, will return empty array, needed for getOwnPropsKeys\n  const getSymbols = Object.getOwnPropertySymbols || (() => []);\n\n  // utils block end\n  // ------------------------------------------------------------------------\n\n  // has own property check, usage: has.call(obj, 'propName');\n  const hasProp = Object.prototype.hasOwnProperty;\n\n  // main object\n  const interf = {\n    // integer count of all versions, current version: 1.0.0\n    VERSION: 1,\n    _config: {\n      // use interf.configure to set config values\n      warn: false,\n      debug: false, // ignored in core build\n      afterImplement: false,\n      descriptor: {\n        // value: (auto-defined, in case when setter is defined will be auto-assigned),\n        configurable: true,\n        writable: false,\n        enumerable: false,\n        // set: undefined,\n        // get: undefined,\n      },\n      callbacks: {\n        warn: function warnCallback(data) {\n          if (typeof console === 'object' && console.warn) console.warn(data.message);\n        },\n        // ignored in core build\n        debug: function debugCallback(data) {\n          if (typeof console === 'object' && console.log) console.log(data.message, data);\n        },\n        afterImplement: function afterImplementCallback(classInterfaces, Class, interfaces) {},\n      },\n      // ignored in core build\n      mixin: {\n        // warn: this.,\n        // debug: false,\n        createInit: true, // create initMixins method in target prototype\n        interfaces: true,\n        replace: true,\n        notConfigurableNotWritableError: true, // ignored if replace == false,\n        // https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\n        ignore: {\n          protoProps: [\n            'constructor',\n            'apply',\n            'bind',\n            'call',\n            'isGenerator',\n            'toSource',\n            'toString',\n            '__proto__',\n          ],\n          staticProps: [\n            'arguments',\n            'arity',\n            'caller',\n            'length',\n            'name',\n            'displayName',\n            'prototype',\n            '__proto__',\n          ],\n        },\n      },\n    },\n  };\n\n  const CAPITAL_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n  function parentHas(target, Interface) {\n    const prototype = getProto(target);\n    if (prototype === null) return false;\n    const interfaces = prototype.constructor.__interfaces_;\n    if (typeof interfaces !== 'undefined' && interfaces.has(Interface)) return true;\n    return parentHas(prototype, Interface);\n  }\n\n  // Base interface class\n  const InterfaceClass = class Interface {\n    constructor(properties) {\n      if (typeof properties.extends !== 'undefined' && !Array.isArray(properties.extends)) {\n        throw TypeError('Interface extends should be an Array');\n      }\n      if (typeof properties.name === 'string' && properties.name.length !== 0) {\n        const keys = Object.keys(properties);\n        let i = keys.length;\n        // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n        while (i--) {\n          if (\n            CAPITAL_CHARS.indexOf(keys[i][0]) > -1 ||\n            keys[i] === 'name' ||\n            keys[i] === 'extends'\n          ) {\n            this[keys[i]] = properties[keys[i]];\n          } else {\n            throw Error('Interface optional property name should start with capital letter');\n          }\n        }\n      } else {\n        throw TypeError('Interface should have a name');\n      }\n    }\n\n    isInterfaceOf(object) {\n      // code repeating here, same as in parentHas()\n      // those solulution works faster than just using of parentHas()\n      // TODO: check in others environments\n      const prototype = getProto(object);\n      if (prototype === null) return false;\n      const interfaces = prototype.constructor.__interfaces_;\n      if (typeof interfaces !== 'undefined' && interfaces.has(this)) return true;\n      return parentHas(prototype, this);\n    }\n  };\n\n  // interf.create(), create Interface\n  function create(interfaceName, extendsArray) {\n    // no need in rest args (...args), also minimize code (babel will transform it\n    // to arguments anyway)\n    const ar = arguments;\n    if (typeof ar[0] === 'string') {\n      const obj = { name: ar[0] };\n      if (typeof ar[1] !== 'undefined') obj.extends = ar[1];\n      return new InterfaceClass(obj);\n    } else if (typeof ar[0] === 'object') {\n      return new InterfaceClass(ar[0]);\n    }\n    throw TypeError(\n      'In method interf.create first parameter should be an object or Interface name'\n    );\n  }\n\n  // Interfaces objects are stored in __interfaces_\n  class Interfaces {\n    constructor(version) {\n      this.collection = [];\n      this.VERSION = version;\n    }\n\n    // add only unique, but not unique in extends or parent\n    // mainly incoming parameter will be arguments object (array like)\n    add(interfaces, constructorName) {\n      const len = interfaces.length;\n      let i = -1;\n      while (++i < len) {\n        let j = this.collection.length;\n        // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n        while (j--) {\n          if (this.collection[j] === interfaces[i]) {\n            throw Error(\n              `Class ${constructorName} cannot implement previously implemented interface ${interfaces[\n                i\n              ].name}`\n            );\n          }\n        }\n\n        this.collection.push(interfaces[i]);\n      }\n      return this;\n    }\n\n    remove(Interface) {\n      let i = this.collection.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        if (Interface === this.collection[i]) {\n          this.collection.splice(i, 1);\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // check instance interfaces\n    // comparison is fastest solution\n    has(Interface) {\n      let i = this.collection.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        if (Interface === this.collection[i]) return true;\n        // check extended interfaces\n        if (\n          typeof this.collection[i].extends === 'object' &&\n          this.extendsHas(Interface, this.collection[i].extends)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    extendsHas(Interface, collection) {\n      let i = collection.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        if (Interface === collection[i]) return true;\n        // check extended interfaces\n        if (\n          typeof collection[i].extends !== 'undefined' &&\n          this.extendsHas(Interface, collection[i].extends)\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function configure(properties) {\n    this._config = assignObjects(this._config, properties);\n\n    // descriptor should be rewrited\n    if (typeof properties.descriptor === 'object') {\n      this._config.descriptor = properties.descriptor;\n    }\n\n    return this;\n  }\n\n  // debug information computing functions\n  let debugs = false;\n\n  // define __interfaces_ in prototype\n  function defineInterfacesProp(proto, parent, options) {\n    const value = new Interfaces(interf.version, parent);\n    const descriptor = assignObjects(options.descriptor); // assign to empty object {}\n\n    if (typeof interf._config.descriptor.set !== 'function') {\n      descriptor.value = value;\n    }\n\n    Object.defineProperty(proto.constructor, '__interfaces_', descriptor);\n    if (typeof descriptor.set === 'function') {\n      proto.constructor.__interfaces_ = value;\n    }\n\n    if (options.debug && debugs) debugs.define(true, proto, value);\n  }\n\n  function validateInterfaces(interfaces) {\n    let i = interfaces.length;\n    while (i--) {\n      if (typeof interfaces[i] !== 'object') {\n        throw TypeError(`Undefined type ${typeof interfaces[i]} of interface`);\n      } else if (typeof interfaces[i].isInterfaceOf !== 'function') {\n        throw TypeError(`Undefined type of interface: ${interfaces[i].name}`);\n      }\n    }\n  }\n\n  // implement interface function\n  function implementIn(prototype, interfaces, options) {\n    validateInterfaces(interfaces);\n\n    const constructor = prototype.constructor;\n\n    if (!hasProp.call(constructor, '__interfaces_')) {\n      defineInterfacesProp(prototype, null, options);\n    }\n\n    // add intefaces to prototype\n    constructor.__interfaces_.add(interfaces, constructor.name);\n\n    if (interf._config.afterImplement) {\n      interf._config.callbacks.afterImplement(constructor.__interfaces_, constructor, interfaces);\n    }\n\n    if (options.debug && debugs) debugs.implement(true, prototype, interfaces);\n\n    return constructor;\n  }\n\n  // remove function\n  function removeIn(prototype, interfaces, options) {\n    validateInterfaces(interfaces);\n\n    const constructor = prototype.constructor;\n    const missed = [];\n    const deleted = [];\n    let collection;\n    let success = false;\n    let interfaced = false;\n    if (hasProp.call(constructor, '__interfaces_')) {\n      collection = constructor.__interfaces_.collection;\n\n      let i = interfaces.length;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (i--) {\n        const index = collection.indexOf(interfaces[i]);\n        let warnMsg = '';\n\n        if (index > -1) {\n          if (constructor.__interfaces_.remove(interfaces[i])) {\n            deleted.push(interfaces[i]);\n\n            if (constructor.__interfaces_.has(interfaces[i])) {\n              warnMsg = `removed, but interface still exist in other interfaces parents.`;\n            }\n\n            if (parentHas(prototype, interfaces[i])) {\n              warnMsg += ` removed, but interface still exist in parents prototypes constructors interfaces.`;\n            }\n          } else {\n            warnMsg = `not removed from own interfaces.`;\n          }\n        } else {\n          warnMsg = `not found in own interfaces.`;\n\n          missed.push(interfaces[i]);\n        }\n\n        if (options.warn && warnMsg.length > 0) {\n          interf._config.callbacks.warn({\n            message: `Constructor ${constructor.name}. Interface ${interfaces[i]\n              .name} was ${warnMsg}`,\n          });\n        }\n      }\n\n      success = deleted.length === interfaces.length;\n\n      interfaced = true;\n    } else if (options.warn) {\n      interf._config.callbacks.warn({\n        message: `Constructor ${constructor.name} none interface was found. Interfaces ${addArray(\n          [],\n          interfaces\n        )\n          .map(Interface => Interface.name)\n          .join(', ')} was not removed from own interfaces.`,\n      });\n    }\n\n    if (options.debug && debugs) {\n      debugs.remove(success, prototype, interfaces, interfaced, deleted, missed);\n    }\n\n    return success;\n  }\n\n  // empty function\n  function emptyIn(prototype, options) {\n    const constructor = prototype.constructor;\n    let success = false;\n    let interfaced = false;\n    if (hasProp.call(constructor, '__interfaces_')) {\n      // create new array\n      const interfaces = addArray([], constructor.__interfaces_.collection);\n      if (interfaces.length !== 0) {\n        success = removeIn(prototype, interfaces, options);\n      }\n\n      interfaced = true;\n    }\n\n    if (options.debug && debugs) debugs.empty(success, prototype, null, interfaced);\n\n    return success;\n  }\n\n  // resolve input arguments\n  function resolveArgs(args, section) {\n    const ret = { values: args, options: {} };\n    let descriptor;\n    if (Array.isArray(args[0])) {\n      ret.values = args[0];\n      if (typeof args[1] === 'object') {\n        ret.options = args[1];\n        if (typeof ret.options.descriptor === 'object') {\n          descriptor = ret.options.descriptor;\n        }\n      }\n    }\n\n    if (typeof section === 'string') {\n      ret.options = assignObjects(interf._config, interf._config[section], ret.options);\n    } else {\n      ret.options = assignObjects(interf._config, ret.options);\n    }\n\n    // special rule for descriptor option\n    // descriptor should be rewrited\n    if (typeof descriptor !== 'undefined') {\n      ret.options.descriptor = descriptor;\n    }\n\n    return ret;\n  }\n\n  // get proto of given in \".in(target)\" method argument\n  function targetProto(target) {\n    if (typeof target === 'function') {\n      return target.prototype;\n    } else if (\n      // check is protolike object\n      typeof target.constructor === 'function' &&\n      target.constructor.prototype === target\n    ) {\n      return target;\n    }\n    throw TypeError(\n      `Wrong target, should be function (class) or prototype of function (class). Current value: ${target}.`\n    );\n  }\n\n  // interf.implement()\n  function implement() {\n    // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n    const args = resolveArgs(arguments);\n    return {\n      in: target => implementIn(targetProto(target), args.values, args.options),\n    };\n  }\n\n  // interf.remove()\n  function remove() {\n    // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n    const args = resolveArgs(arguments);\n    return {\n      in: target => removeIn(targetProto(target), args.values, args.options),\n    };\n  }\n\n  // interf.empty()\n  function empty(options) {\n    const opts = resolveArgs([[], options]).options;\n    return {\n      in: target => emptyIn(targetProto(target), opts),\n    };\n  }\n\n  // core\n  interf.create = create;\n  interf.implement = implement;\n  interf.remove = remove;\n  interf.empty = empty;\n  interf.configure = configure;\n  // core additional\n  interf.utils = {\n    getProto,\n    getSymbols,\n    addArray,\n    mergeObjects,\n    assignObjects,\n  };\n  interf.internal = {\n    Interface: InterfaceClass,\n    Interfaces,\n    implementIn,\n    removeIn,\n    emptyIn,\n    debugs,\n    resolveArgs,\n    targetProto,\n  };\n\n  // @NOT_CORE_BEGIN@\n\n  // Interface for objects mixined with classes with constructor method, and mark that initMixins method are able\n  const MixinsInitiable = create({\n    name: 'MixinsInitiable',\n    Comments: ['Class with this interface may init values provided by mixins'],\n    Methods: ['initMixins'],\n    StaticProperties: ['__mixins_: class[]'],\n    Docs: '//shvabuk.github.io/interf',\n  });\n\n  // class for getting debug information\n  class DebugInterfaces {\n    constructor(prototype) {\n      this.tree = [];\n      this.initTree(prototype);\n      this.list = [];\n      this.initList();\n    }\n\n    // use proto chain here because we need proto info, that may not provided by parent property\n    initTree(prototype) {\n      let proto = prototype;\n      while (true) {\n        if (proto === null) {\n          break;\n        }\n\n        if (hasProp.call(proto.constructor, '__interfaces_')) {\n          const interfs = proto.constructor.__interfaces_.collection;\n          this.tree.unshift({\n            constructorName: proto.constructor.name,\n            proto,\n            interfaces: interfs,\n          });\n        }\n\n        proto = getProto(proto);\n      }\n      return this.tree;\n    }\n\n    initList() {\n      const len = this.tree.length;\n      let i = -1;\n      // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n      while (++i < len) {\n        this.addInfo(\n          this.tree[i].proto,\n          this.tree[i].interfaces,\n          this.tree[i].constructorName,\n          false\n        );\n      }\n      return this.list;\n    }\n\n    addInfo(proto, collection, constructorName, extended) {\n      const len = collection.length;\n      let i = -1;\n      while (++i < len) {\n        const InterFace = collection[i];\n        const info = { constructorName, asExtendedInterface: extended, proto };\n        let result;\n        let j = this.list.length;\n        // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n        while (j--) {\n          if (this.list[j].interface === InterFace) {\n            result = this.list[j];\n            break;\n          }\n        }\n        if (typeof result === 'undefined') {\n          this.list.push({ interface: InterFace, implementedIn: [info] });\n        } else {\n          result.implementedIn.push(info);\n        }\n\n        if (typeof InterFace.extends !== 'undefined') {\n          this.addInfo(proto, InterFace.extends, constructorName, true);\n        }\n      }\n      return this.list;\n    }\n\n    getDuplicates() {\n      const results = [];\n\n      const len = this.list.length;\n      let i = -1;\n      while (++i < len) {\n        if (this.list[i].implementedIn.length > 1) results.push(this.list[i]);\n      }\n\n      return results;\n    }\n\n    getList() {\n      return this.list;\n    }\n\n    getTree() {\n      return this.tree;\n    }\n  }\n\n  debugs = {\n    define: (success, proto, value) => {\n      interf._config.callbacks.debug({\n        operation: 'define',\n        success,\n        message: `Constructor ${proto.constructor.name} prototype property __interfaces_ defined`,\n        value,\n        Constructor: proto.constructor,\n      });\n    },\n    implement: (success, proto, value) => {\n      const allInterfaces = new DebugInterfaces(proto).getList();\n      interf._config.callbacks.debug({\n        operation: 'implement',\n        success,\n        message: `Constructor ${proto.constructor\n          .name} implemented own interfaces: ${proto.constructor.__interfaces_.collection\n          .map(InterFace => InterFace.name)\n          .join(', ')}. All ${proto.constructor.name} interfaces: ${allInterfaces\n          .map(data => data.interface.name)\n          .join(', ')}`,\n        value,\n        allInterfaces,\n        Constructor: proto.constructor,\n      });\n    },\n    remove: (success, proto, interfs, interfaced, deleted, missed) => {\n      if (interfaced) {\n        const stillExist = [];\n        const interfacesList = new DebugInterfaces(proto).getList();\n        const listLen = interfacesList.length;\n        let i = -1;\n        while (++i < listLen) {\n          const len = interfs.length;\n          let j = -1;\n          while (++j < len) {\n            if (interfacesList[i].interface === interfs[j]) {\n              stillExist.push(interfacesList[i]);\n              break;\n            }\n          }\n        }\n\n        const data = {\n          operation: 'remove',\n          success,\n          message: `Constructor ${proto.constructor.name}.${(deleted.length > 0\n            ? ` Own interfaces: ${deleted.map(InterFace => InterFace.name).join(', ')} was deleted.`\n            : '') +\n            (missed.length > 0\n              ? ` Own interfaces: ${missed\n                  .map(InterFace => InterFace.name)\n                  .join(', ')} was not found in ${proto.constructor.name} interfaces collection.`\n              : '') +\n            (stillExist.length > 0\n              ? ` Interfaces: ${stillExist\n                  .map(listednterface => listednterface.interface.name)\n                  .join(', ')} still exist in parents constructor prototypes or parents interfaces.`\n              : '')}`,\n          value: interfs,\n          Constructor: proto.constructor,\n          deleted,\n          missed,\n          stillExist,\n          list: interfacesList,\n        };\n\n        interf._config.callbacks.debug(data);\n      } else {\n        interf._config.callbacks.debug({\n          operation: 'remove',\n          success,\n          message: `Constructor ${proto.constructor\n            .name} does not implement interf interfaces. Interface removing is not possible`,\n          value: interfs,\n          Constructor: proto.constructor,\n        });\n      }\n    },\n    empty: (success, proto, value, interfaced) => {\n      if (interfaced) {\n        interf._config.callbacks.debug({\n          operation: 'empty',\n          success,\n          message: `Constructor ${proto.constructor.name} empty ${success\n            ? ''\n            : 'not '}all own interfaces`,\n          value,\n          Constructor: proto.constructor,\n        });\n      } else {\n        interf._config.callbacks.debug({\n          operation: 'empty',\n          success: false,\n          message: `Constructor ${proto.constructor\n            .name} does not implement interf interfaces. Interface empty is not possible`,\n          value,\n          Constructor: proto.constructor,\n        });\n      }\n    },\n    mixProperties: (success, target, mixin, debugData) => {\n      const data = debugData;\n      const isPrototype = typeof target !== 'function';\n      data.success = success;\n      data.Constructor = isPrototype ? target.constructor : target;\n      data.message = `Constructor ${data.Constructor.name +\n        (isPrototype ? ' prototype' : '')} mixed with ${(isPrototype\n        ? mixin.constructor.name\n        : mixin.name) + (isPrototype ? ' prototype' : '')} properties.${data.notReplaced.length > 0\n        ? ` Not replaced properties: ${data.notReplaced.join(', ')}`\n        : ''}`;\n\n      data.value = mixin;\n      interf._config.callbacks.debug(data);\n    },\n  };\n\n  // get props names, used in mixin\n  function getOwnPropsKeys(target) {\n    return addArray(Object.getOwnPropertyNames(target), getSymbols(target));\n  }\n\n  function implementByMixIn(target, interfaces, options) {\n    const prototype = targetProto(target);\n    // create new array, transform arguments to array\n    const interfs = addArray([], interfaces);\n\n    let i = interfs.length;\n    // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n    while (i--) {\n      // ignore duplicates\n      if (\n        hasProp.call(prototype.constructor, '__interfaces_') &&\n        prototype.constructor.__interfaces_.collection.indexOf(interfs[i]) > -1\n      ) {\n        interfs.splice(i, 1);\n      }\n    }\n\n    return implementIn(prototype, interfs, options);\n  }\n\n  // define mixin (constructor or prototype) properties\n  function defineProps(target, mixin, options, ignore) {\n    const mixinNames = getOwnPropsKeys(mixin);\n    const targetNames = getOwnPropsKeys(target);\n    const debugData = {\n      operation: 'mixProperties',\n      target,\n      mixin,\n      ignoredNames: [],\n      notReplaced: [],\n      replaced: [],\n      defined: [],\n      writed: [],\n    };\n\n    let i = mixinNames.length;\n    // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n    while (i--) {\n      // ignore props from ignorelist\n      if (ignore.indexOf(mixinNames[i]) > -1) {\n        if (options.debug) debugData.ignoredNames.push(mixinNames[i]);\n        continue;\n      }\n      // implement interfaces\n      if (mixinNames[i] === '__interfaces_') {\n        if (options.interfaces) {\n          implementByMixIn(target, mixin.__interfaces_.collection, options);\n          if (options.debug) debugData.interfaces = mixin.__interfaces_.collection;\n        }\n        continue;\n      }\n\n      const descriptor = Object.getOwnPropertyDescriptor(mixin, mixinNames[i]);\n      // check prop name in target\n      if (targetNames.indexOf(mixinNames[i]) > -1) {\n        // add mixins constructors if exists\n        if (mixinNames[i] === '__mixins_') {\n          addArray(target.__mixins_, mixin.__mixins_);\n          if (options.debug) debugData.mixins = mixin.__mixins_;\n        } else {\n          const isProto = typeof target === 'object';\n\n          if (options.warn) {\n            interf._config.callbacks.warn({\n              message: `Target ${isProto\n                ? `${target.constructor.name} prototype`\n                : target.name} alredy have mixin (${isProto\n                ? `${mixin.constructor.name} prototype`\n                : mixin.name}) property \"${mixinNames[i]}\". Will be ${options.replace\n                ? 'replaced'\n                : 'ignored'}.`,\n            });\n          }\n\n          if (options.replace) {\n            // resolve conflicts\n            const targetDescriptor = Object.getOwnPropertyDescriptor(target, mixinNames[i]);\n            if (!targetDescriptor.configurable) {\n              if (targetDescriptor.writable) {\n                // write property\n                target[mixinNames[i]] = mixin[mixinNames[i]];\n                if (options.debug) debugData.writed.push(mixinNames[i]);\n              } else if (options.notConfigurableNotWritableError) {\n                try {\n                  // show some additional info\n                  console.error(\n                    'Trying to define not configurable and not writable value. Interf mixin debug info',\n                    debugData\n                  );\n                } catch (e) {}\n                // force error throwing\n                Object.defineProperty(target, mixinNames[i], descriptor);\n              } else {\n                // ignore if options.notConfigurableNotWritableError = false and targetDescriptor.configurable true\n                if (options.debug) debugData.notReplaced.push(mixinNames[i]);\n                if (options.warn) {\n                  interf._config.callbacks.warn({\n                    message: `Mixin ${isProto\n                      ? `${mixin.constructor.name} prototype`\n                      : mixin.name} property \"${mixinNames[\n                      i\n                    ]}\" ignored, because is not writable and not configurable`,\n                  });\n                }\n              }\n            } else {\n              // replace value\n              Object.defineProperty(target, mixinNames[i], descriptor);\n              if (options.debug) debugData.replaced.push(mixinNames[i]);\n            }\n          } else if (options.debug) {\n            // ignore if options.replace == false\n            debugData.notReplaced.push(mixinNames[i]);\n          }\n        }\n      } else {\n        // define property\n        Object.defineProperty(target, mixinNames[i], descriptor);\n        if (options.debug) debugData.defined.push(mixinNames[i]);\n      }\n    }\n\n    if (options.debug && debugs) debugs.mixProperties(true, target, mixin, debugData);\n  }\n\n  // return initMixins function, MixinsInitiable objects method\n  // may be used if interf._config.mixin.createInit or options.createInit is true\n  function createInitMixins(replace) {\n    return function initMixins() {\n      // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n      let prototype = getProto(this);\n      while (true) {\n        if (prototype === null) {\n          break;\n        }\n\n        if (hasProp.call(prototype.constructor, '__mixins_')) {\n          const length = prototype.constructor.__mixins_.length;\n          let j = -1;\n          while (++j < length) {\n            // const mixinObject = new prototype.constructor.__mixins_[j](...args);\n            // compiled by babel\n            const mixinObject = new (Function.prototype.bind.apply(\n              prototype.constructor.__mixins_[j],\n              addArray([null], arguments)\n            ))();\n            const keys = Object.keys(mixinObject);\n            let i = keys.length;\n            // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n            while (i--) {\n              if (typeof this[keys[i]] === 'undefined' || replace) {\n                this[keys[i]] = mixinObject[keys[i]];\n              }\n            }\n          }\n        }\n\n        prototype = getProto(prototype);\n      }\n    };\n  }\n\n  // mixin function\n  function mixIn(targetPrototype, mixins, options) {\n    const mixinsConstructors = [];\n    const len = mixins.length;\n    let i = -1;\n    while (++i < len) {\n      const mixinProto = targetProto(mixins[i]);\n      defineProps(targetPrototype, mixinProto, options, options.ignore.protoProps);\n      defineProps(\n        targetPrototype.constructor,\n        mixinProto.constructor,\n        options,\n        options.ignore.staticProps\n      );\n      if (options.createInit) mixinsConstructors.push(mixinProto.constructor);\n    }\n\n    if (options.createInit) {\n      if (\n        typeof targetPrototype.__interfaces_ === 'undefined' ||\n        !targetPrototype.__interfaces_.has(MixinsInitiable)\n      ) {\n        Object.defineProperty(targetPrototype, 'initMixins', {\n          configurable: true,\n          writable: true,\n          value: createInitMixins(!!options.replace), // always convert replace to primitive\n        });\n\n        if (\n          typeof targetPrototype.constructor.__interfaces_ !== 'object' ||\n          targetPrototype.constructor.__interfaces_.collection.indexOf(MixinsInitiable) === -1\n        ) {\n          implement(MixinsInitiable).in(targetPrototype);\n        }\n      }\n\n      if (hasProp.call(targetPrototype.constructor, '__mixins_')) {\n        addArray(targetPrototype.constructor.__mixins_, mixinsConstructors);\n      } else {\n        Object.defineProperty(targetPrototype.constructor, '__mixins_', {\n          configurable: true,\n          writable: true,\n          value: mixinsConstructors,\n        });\n      }\n    }\n\n    return targetPrototype.constructor;\n  }\n\n  // debug function\n  function debugIn(prototype, actions) {\n    const information = {};\n    let i = actions.length;\n    const debugInfo = new DebugInterfaces(prototype);\n\n    // while(i--) loop faster than any array buildin loops [].map(), [].find() etc.\n    while (i--) {\n      if (actions[i] === 'duplicates') {\n        information.duplicates = debugInfo.getDuplicates();\n      } else if (actions[i] === 'tree') {\n        information.tree = debugInfo.getTree();\n      } else if (actions[i] === 'list') {\n        information.list = debugInfo.getList();\n      }\n    }\n\n    return information;\n  }\n\n  // interf.debug() resolve given arguments and run debug\n  function debug(action) {\n    const allActions = ['duplicates', 'tree', 'list'];\n    let values;\n    if (typeof action === 'undefined') {\n      values = allActions;\n    } else if (typeof action === 'string') {\n      if (action === 'all') {\n        values = allActions;\n      } else {\n        values = [action];\n      }\n    } else if (Array.isArray(action)) {\n      values = action;\n    } else {\n      throw TypeError(\n        `debug first argument should be undefined, array, or string (${allActions.join(', ')}, all)`\n      );\n    }\n\n    return {\n      in: target => debugIn(targetProto(target), values),\n    };\n  }\n\n  // interf.mix()\n  function mix() {\n    // no need in rest args (...args), also minimize code (babel will transform it to arguments anyway)\n    const args = resolveArgs(arguments, 'mixin');\n\n    return {\n      in: target => mixIn(targetProto(target), args.values, args.options),\n    };\n  }\n\n  // full\n  interf.mix = mix;\n  interf.debug = debug;\n  // additional\n  interf.interfaces = { MixinsInitiable };\n  interf.internal.DebugInterfaces = DebugInterfaces;\n  interf.internal.mixIn = mixIn;\n  interf.internal.debugIn = debugIn;\n  interf.internal.debugs = debugs;\n\n  // @NOT_CORE_END@\n\n  return interf;\n});\n"]}