/**
 * @license
 * Interf <https://shvabuk.github.io/interf>
 * Released under MIT license <https://shvabuk.github.io/interf/LICENSE.txt>
 * Copyright Shvab Ostap
 */
;(function(e,t){if("function"==typeof define&&define.amd)define([],t);else if("object"==typeof module&&module.exports){var r=t();module.exports=r,module.exports.interf=r}else"object"==typeof exports&&"string"!=typeof exports.nodeName?exports.interf=t():"object"==typeof e.interf&&Number.isInteger(e.interf.VERSION)||(e.interf=t())})(this,function(){"use strict";function e(){for(var e=arguments,t=arguments.length,r=-1,n={};++r<t;)n=y(n,e[r]);return n}function t(e,r){var n=h(e);if(null===n)return!1;var o=n.constructor.__interfaces_;return!(void 0===o||!o.has(r))||t(n,r)}function r(e,t){var r=arguments;if("string"==typeof r[0]){var n={name:r[0]};return void 0!==r[1]&&(n.extends=r[1]),new j(n)}if("object"==typeof r[0])return new j(r[0]);throw TypeError("In method interf.create first parameter should be an object or Interface name")}function n(t,r,n){var o=new O(w.version,r),i=e(n.descriptor);"function"!=typeof w._config.descriptor.set&&(i.value=o),Object.defineProperty(t.constructor,"__interfaces_",i),"function"==typeof i.set&&(t.constructor.__interfaces_=o),n.debug&&C&&C.define(!0,t,o)}function o(e){for(var t=e.length;t--;){if("object"!=typeof e[t])throw TypeError("Undefined type "+typeof e[t]+" of interface");if("function"!=typeof e[t].isInterfaceOf)throw TypeError("Undefined type of interface: "+e[t].name)}}function i(e,t,r){o(t);var i=e.constructor;return x.call(i,"__interfaces_")||n(e,null,r),i.__interfaces_.add(t,i.name),w._config.afterImplement&&w._config.callbacks.afterImplement(i.__interfaces_,i,t),r.debug&&C&&C.implement(!0,e,t),i}function c(e,r,n){o(r);var i=e.constructor,c=[],s=[],a=void 0,f=!1,u=!1;if(x.call(i,"__interfaces_")){a=i.__interfaces_.collection;for(var l=r.length;l--;){var p="";a.indexOf(r[l])>-1?i.__interfaces_.remove(r[l])?(s.push(r[l]),i.__interfaces_.has(r[l])&&(p="removed, but interface still exist in other interfaces parents."),t(e,r[l])&&(p+=" removed, but interface still exist in parents prototypes constructors interfaces.")):p="not removed from own interfaces.":(p="not found in own interfaces.",c.push(r[l])),n.warn&&p.length>0&&w._config.callbacks.warn({message:"Constructor "+i.name+". Interface "+r[l].name+" was "+p})}f=s.length===r.length,u=!0}else n.warn&&w._config.callbacks.warn({message:"Constructor "+i.name+" none interface was found. Interfaces "+b([],r).map(function(e){return e.name}).join(", ")+" was not removed from own interfaces."});return n.debug&&C&&C.remove(f,e,r,u,s,c),f}function s(e,t){var r=e.constructor,n=!1,o=!1;if(x.call(r,"__interfaces_")){var i=b([],r.__interfaces_.collection);0!==i.length&&(n=c(e,i,t)),o=!0}return t.debug&&C&&C.empty(n,e,null,o),n}function a(t,r){var n={values:t,options:{}},o=void 0;return Array.isArray(t[0])&&(n.values=t[0],"object"==typeof t[1]&&(n.options=t[1],"object"==typeof n.options.descriptor&&(o=n.options.descriptor))),n.options="string"==typeof r?e(w._config,w._config[r],n.options):e(w._config,n.options),void 0!==o&&(n.options.descriptor=o),n}function f(e){if("function"==typeof e)return e.prototype;if("function"==typeof e.constructor&&e.constructor.prototype===e)return e;throw TypeError("Wrong target, should be function (class) or prototype of function (class). Current value: "+e+".")}function u(){var e=a(arguments);return{in:function(t){return i(f(t),e.values,e.options)}}}function l(e){return b(Object.getOwnPropertyNames(e),v(e))}function p(e,t,r){for(var n=f(e),o=b([],t),c=o.length;c--;)x.call(n.constructor,"__interfaces_")&&n.constructor.__interfaces_.collection.indexOf(o[c])>-1&&o.splice(c,1);return i(n,o,r)}function d(e,t,r,n){for(var o=l(t),i=l(e),c={operation:"mixProperties",target:e,mixin:t,ignoredNames:[],notReplaced:[],replaced:[],defined:[],writed:[]},s=o.length;s--;)if(n.indexOf(o[s])>-1)r.debug&&c.ignoredNames.push(o[s]);else if("__interfaces_"!==o[s]){var a=Object.getOwnPropertyDescriptor(t,o[s]);if(i.indexOf(o[s])>-1)if("__mixins_"===o[s])b(e.__mixins_,t.__mixins_),r.debug&&(c.mixins=t.__mixins_);else{var f="object"==typeof e;if(r.warn&&w._config.callbacks.warn({message:"Target "+(f?e.constructor.name+" prototype":e.name)+" alredy have mixin ("+(f?t.constructor.name+" prototype":t.name)+') property "'+o[s]+'". Will be '+(r.replace?"replaced":"ignored")+"."}),r.replace){var u=Object.getOwnPropertyDescriptor(e,o[s]);if(u.configurable)Object.defineProperty(e,o[s],a),r.debug&&c.replaced.push(o[s]);else if(u.writable)e[o[s]]=t[o[s]],r.debug&&c.writed.push(o[s]);else if(r.notConfigurableNotWritableError){try{console.error("Trying to define not configurable and not writable value. Interf mixin debug info",c)}catch(e){}Object.defineProperty(e,o[s],a)}else r.debug&&c.notReplaced.push(o[s]),r.warn&&w._config.callbacks.warn({message:"Mixin "+(f?t.constructor.name+" prototype":t.name)+' property "'+o[s]+'" ignored, because is not writable and not configurable'})}else r.debug&&c.notReplaced.push(o[s])}else Object.defineProperty(e,o[s],a),r.debug&&c.defined.push(o[s])}else r.interfaces&&(p(e,t.__interfaces_.collection,r),r.debug&&(c.interfaces=t.__interfaces_.collection));r.debug&&C&&C.mixProperties(!0,e,t,c)}function m(e){return function(){for(var t=arguments,r=this,n=h(this);;){if(null===n)break;if(x.call(n.constructor,"__mixins_"))for(var o=n.constructor.__mixins_.length,i=-1;++i<o;)for(var c=new(Function.prototype.bind.apply(n.constructor.__mixins_[i],b([null],t))),s=Object.keys(c),a=s.length;a--;)(void 0===r[s[a]]||e)&&(r[s[a]]=c[s[a]]);n=h(n)}}}function g(e,t,r){for(var n=[],o=t.length,i=-1;++i<o;){var c=f(t[i]);d(e,c,r,r.ignore.protoProps),d(e.constructor,c.constructor,r,r.ignore.staticProps),r.createInit&&n.push(c.constructor)}return r.createInit&&(void 0!==e.__interfaces_&&e.__interfaces_.has(P)||(Object.defineProperty(e,"initMixins",{configurable:!0,writable:!0,value:m(!!r.replace)}),"object"==typeof e.constructor.__interfaces_&&-1!==e.constructor.__interfaces_.collection.indexOf(P)||u(P).in(e)),x.call(e.constructor,"__mixins_")?b(e.constructor.__mixins_,n):Object.defineProperty(e.constructor,"__mixins_",{configurable:!0,writable:!0,value:n})),e.constructor}function _(e,t){for(var r={},n=t.length,o=new k(e);n--;)"duplicates"===t[n]?r.duplicates=o.getDuplicates():"tree"===t[n]?r.tree=o.getTree():"list"===t[n]&&(r.list=o.getList());return r}var h=Object.getPrototypeOf||function(e){return e.__proto__},b=function(e,t){for(var r=t.length,n=-1;++n<r;)e.push(t[n]);return e},y=function e(t,r){for(var n=t,o=Object.keys(r),i=o.length;i--;)Array.isArray(r[o[i]])?Array.isArray(n[o[i]])?n[o[i]]=b(n[o[i]],r[o[i]]):n[o[i]]=b([],r[o[i]]):"object"==typeof r[o[i]]?"object"==typeof n[o[i]]?n[o[i]]=e(n[o[i]],r[o[i]]):n[o[i]]=e({},r[o[i]]):n[o[i]]=r[o[i]];return n},v=Object.getOwnPropertySymbols||function(){return[]},x=Object.prototype.hasOwnProperty,w={VERSION:1,_config:{warn:!1,debug:!1,afterImplement:!1,descriptor:{configurable:!0,writable:!1,enumerable:!1},callbacks:{warn:function(e){"object"==typeof console&&console.warn&&console.warn(e.message)},debug:function(e){"object"==typeof console&&console.log&&console.log(e.message,e)},afterImplement:function(e,t,r){}},mixin:{createInit:!0,interfaces:!0,replace:!0,notConfigurableNotWritableError:!0,ignore:{protoProps:["constructor","apply","bind","call","isGenerator","toSource","toString","__proto__"],staticProps:["arguments","arity","caller","length","name","displayName","prototype","__proto__"]}}}},I="ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""),j=function(){function e(e){var t=this;if(void 0!==e.extends&&!Array.isArray(e.extends))throw TypeError("Interface extends should be an Array");if("string"!=typeof e.name||0===e.name.length)throw TypeError("Interface should have a name");for(var r=Object.keys(e),n=r.length;n--;){if(!(I.indexOf(r[n][0])>-1||"name"===r[n]||"extends"===r[n]))throw Error("Interface optional property name should start with capital letter");t[r[n]]=e[r[n]]}}return e.prototype.isInterfaceOf=function(e){var r=h(e);if(null===r)return!1;var n=r.constructor.__interfaces_;return!(void 0===n||!n.has(this))||t(r,this)},e}(),O=function(e){this.collection=[],this.VERSION=e};O.prototype.add=function(e,t){for(var r=this,n=e.length,o=-1;++o<n;){for(var i=r.collection.length;i--;)if(r.collection[i]===e[o])throw Error("Class "+t+" cannot implement previously implemented interface "+e[o].name);r.collection.push(e[o])}return this},O.prototype.remove=function(e){for(var t=this,r=this.collection.length;r--;)if(e===t.collection[r])return t.collection.splice(r,1),!0;return!1},O.prototype.has=function(e){for(var t=this,r=this.collection.length;r--;){if(e===t.collection[r])return!0;if("object"==typeof t.collection[r].extends&&t.extendsHas(e,t.collection[r].extends))return!0}return!1},O.prototype.extendsHas=function(e,t){for(var r=this,n=t.length;n--;){if(e===t[n])return!0;if(void 0!==t[n].extends&&r.extendsHas(e,t[n].extends))return!0}return!1};var C=!1;w.create=r,w.implement=u,w.remove=function(){var e=a(arguments);return{in:function(t){return c(f(t),e.values,e.options)}}},w.empty=function(e){var t=a([[],e]).options;return{in:function(e){return s(f(e),t)}}},w.configure=function(t){return this._config=e(this._config,t),"object"==typeof t.descriptor&&(this._config.descriptor=t.descriptor),this},w.utils={getProto:h,getSymbols:v,addArray:b,mergeObjects:y,assignObjects:e},w.internal={Interface:j,Interfaces:O,implementIn:i,removeIn:c,emptyIn:s,debugs:C,resolveArgs:a,targetProto:f};var P=r({name:"MixinsInitiable",Comments:["Class with this interface may init values provided by mixins"],Methods:["initMixins"],StaticProperties:["__mixins_: class[]"],Docs:"//shvabuk.github.io/interf"}),k=function(e){this.tree=[],this.initTree(e),this.list=[],this.initList()};return k.prototype.initTree=function(e){for(var t=this,r=e;;){if(null===r)break;if(x.call(r.constructor,"__interfaces_")){var n=r.constructor.__interfaces_.collection;t.tree.unshift({constructorName:r.constructor.name,proto:r,interfaces:n})}r=h(r)}return this.tree},k.prototype.initList=function(){for(var e=this,t=this.tree.length,r=-1;++r<t;)e.addInfo(e.tree[r].proto,e.tree[r].interfaces,e.tree[r].constructorName,!1);return this.list},k.prototype.addInfo=function(e,t,r,n){for(var o=this,i=t.length,c=-1;++c<i;){for(var s=t[c],a={constructorName:r,asExtendedInterface:n,proto:e},f=void 0,u=o.list.length;u--;)if(o.list[u].interface===s){f=o.list[u];break}void 0===f?o.list.push({interface:s,implementedIn:[a]}):f.implementedIn.push(a),void 0!==s.extends&&o.addInfo(e,s.extends,r,!0)}return this.list},k.prototype.getDuplicates=function(){for(var e=this,t=[],r=this.list.length,n=-1;++n<r;)e.list[n].implementedIn.length>1&&t.push(e.list[n]);return t},k.prototype.getList=function(){return this.list},k.prototype.getTree=function(){return this.tree},C={define:function(e,t,r){w._config.callbacks.debug({operation:"define",success:e,message:"Constructor "+t.constructor.name+" prototype property __interfaces_ defined",value:r,Constructor:t.constructor})},implement:function(e,t,r){var n=new k(t).getList();w._config.callbacks.debug({operation:"implement",success:e,message:"Constructor "+t.constructor.name+" implemented own interfaces: "+t.constructor.__interfaces_.collection.map(function(e){return e.name}).join(", ")+". All "+t.constructor.name+" interfaces: "+n.map(function(e){return e.interface.name}).join(", "),value:r,allInterfaces:n,Constructor:t.constructor})},remove:function(e,t,r,n,o,i){if(n){for(var c=[],s=new k(t).getList(),a=s.length,f=-1;++f<a;)for(var u=r.length,l=-1;++l<u;)if(s[f].interface===r[l]){c.push(s[f]);break}var p={operation:"remove",success:e,message:"Constructor "+t.constructor.name+"."+(o.length>0?" Own interfaces: "+o.map(function(e){return e.name}).join(", ")+" was deleted.":"")+(i.length>0?" Own interfaces: "+i.map(function(e){return e.name}).join(", ")+" was not found in "+t.constructor.name+" interfaces collection.":"")+(c.length>0?" Interfaces: "+c.map(function(e){return e.interface.name}).join(", ")+" still exist in parents constructor prototypes or parents interfaces.":""),value:r,Constructor:t.constructor,deleted:o,missed:i,stillExist:c,list:s};w._config.callbacks.debug(p)}else w._config.callbacks.debug({operation:"remove",success:e,message:"Constructor "+t.constructor.name+" does not implement interf interfaces. Interface removing is not possible",value:r,Constructor:t.constructor})},empty:function(e,t,r,n){n?w._config.callbacks.debug({operation:"empty",success:e,message:"Constructor "+t.constructor.name+" empty "+(e?"":"not ")+"all own interfaces",value:r,Constructor:t.constructor}):w._config.callbacks.debug({operation:"empty",success:!1,message:"Constructor "+t.constructor.name+" does not implement interf interfaces. Interface empty is not possible",value:r,Constructor:t.constructor})},mixProperties:function(e,t,r,n){var o=n,i="function"!=typeof t;o.success=e,o.Constructor=i?t.constructor:t,o.message="Constructor "+o.Constructor.name+(i?" prototype":"")+" mixed with "+(i?r.constructor.name:r.name)+(i?" prototype":"")+" properties."+(o.notReplaced.length>0?" Not replaced properties: "+o.notReplaced.join(", "):""),o.value=r,w._config.callbacks.debug(o)}},w.mix=function(){var e=a(arguments,"mixin");return{in:function(t){return g(f(t),e.values,e.options)}}},w.debug=function(e){var t=["duplicates","tree","list"],r=void 0;if(void 0===e)r=t;else if("string"==typeof e)r="all"===e?t:[e];else{if(!Array.isArray(e))throw TypeError("debug first argument should be undefined, array, or string ("+t.join(", ")+", all)");r=e}return{in:function(e){return _(f(e),r)}}},w.interfaces={MixinsInitiable:P},w.internal.DebugInterfaces=k,w.internal.mixIn=g,w.internal.debugIn=_,w.internal.debugs=C,w});
//# sourceMappingURL=interf.min.js.map
